msgid ""
msgstr "Project-Id-Version: Game v4.23.0-rc2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-24\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: Game.Levels.L6Pset.L6Pset3
msgid "# Problem 3\n"
"\n"
"You are given that a sequence `a : ℕ → ℝ` converges to 5.\n"
"Prove that it is eventually positive."
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "Prove the \\\"Archimedean Property\\\"\n"
"that no matter how small `ε > 0` may be,\n"
"there is always a natural number `N` with `1 / ε < N`."
msgstr ""

#: Game.Levels.L10Pset.L10Pset6
msgid "# Problem 5:\n"
"\n"
"Show that the sequence `a n = n` is unbounded."
msgstr ""

#: Game.Levels.L7Levels.L02_SeqOfAbs
msgid "The absolute value function is Lipschitz with constant 1."
msgstr ""

#: Game.Levels.L10Pset.L10Pset5
msgid "# Problem 4:\n"
"\n"
"Exhibit (by starting with `let a : ℕ → ℝ := fun n ↦ ???`)\n"
"a sequence so that\n"
"\n"
"- the terms are all strictly positive: `∀ n, 0 < a n`,\n"
"- and yet the sequence converges to zero (and not something strictly positive!).\n"
"\n"
"When you define a new sequence using `let`, you might find it\n"
"convenient to immediately prove a trivial theorem restating the definition:\n"
"\n"
"`have ha : ∀ n, a n = ??? := by intro n; rfl`\n"
"\n"
"This may become useful should you want to `rewrite` by `ha` (you can't rewrite by `a`, since it's a definition, not a theorem!)...\n"
"\n"
"**Extra challenge:** See if you can do it by using theorems we already proved, not by going into the `ε-N` definition..."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "The `use` tactic provides a specific value to prove an existence statement."
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "You can't use `abs_mul` just yet, because you don't have a product of things inside the absolute values! So first factor out the 2: `have factor : 2 * a n - 2 * L = 2 * (a n - L) := by ring_nf`"
msgstr ""

#: Game
msgid "Learn real analysis through the historical crises that forced mathematicians to rebuild calculus from the ground up in the 19th century."
msgstr ""

#: Game.Levels.L7Levels.L04_ByCases
msgid "ByCases"
msgstr ""

#: Game.Levels.L14Lecture
msgid "# Lecture 14: Bolzano-Weierstrass"
msgstr ""

#: Game.Levels.L11Levels.L01_IsCauchyOfLim
msgid "# Congratulations! You've proven that convergence implies Cauchy!\n"
"\n"
"This is one of the most fundamental results in analysis. You've just shown that the \"self-referential\" Cauchy property is a *necessary condition* for convergence.\n"
"\n"
"## What you've learned\n"
"\n"
"- How to work with the Cauchy definition using multiple indices `m` and `n`\n"
"- The power of the `ε/2` trick to make inequalities work out\n"
"- How to use `abs_sub_comm` to flip differences inside absolute values\n"
"- How to connect a sequence to itself rather than to an external limit\n"
"\n"
"## The Big Question\n"
"\n"
"You've proven: **convergence ⟹ Cauchy**\n"
"\n"
"But what about the converse? Is every Cauchy sequence convergent?\n"
"\n"
"- **For rational sequences**: NO! The sequence `1, 1.4, 1.41, 1.414, ...` is Cauchy in ℚ but doesn't converge to a rational number.\n"
"- **For real sequences**: This is the *Cauchy Completeness Theorem*, and it's **YES**! But we'll need to carefully construct the real numbers first to prove it.\n"
"\n"
"This is why Cauchy sequences are so important—they give us a way to *define* the real numbers as the completion of the rationals!\n"
"\n"
"Onward to the next level!"
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "`(a : ℕ → ℝ) := ∃ L, SeqLim a L`\n"
"\n"
"A sequence `a : N → ℝ` converges (`SeqConv a` holds) if there exists some\n"
"`L : ℝ` so that `a → L`, that is, `SeqLim a L` holds."
msgstr ""

#: Game.Levels.L6Levels.L04_Cases'
msgid "When have a hypothesis `h : P ∨ Q`, you can say `cases' h with h1 h2`; this will make two new Game Boards, one with an extra hypothesis `h1 : P`, and the other with the hypothesis `h2 : Q`. You'll have to solve both to solve the original Goal!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "The `rfl` tactic proves goals of the form `A = A` where both sides are *identical*."
msgstr ""

#: Game.Levels.L11Levels.L01_IsCauchyOfLim
msgid "Big Boss : Limits are Cauchy"
msgstr ""

#: Game.Levels.L6Levels.L00_SumOfSeqs
msgid "Prove that the sum of two convergent sequences converges to the sum of their limits.\n"
"This is the mathematician's version of 'if two factories each meet their quality standards, their combined output will too!'"
msgstr ""

#: Game.Levels.L10Levels.L08_Mono
msgid "Beautiful! That was remarkably simple for such a powerful theorem.\n"
"\n"
"**Why This Proof Works:**\n"
"\n"
"The key insight is that subsequences can only \"spread out\" indices, never compress them. Since `σ(n) ≥ n` always, if `a` is eventually within `ε` of `L` (for all indices ≥ N), then `a ∘ σ` is too—because `σ` maps `n ≥ N` to even larger indices where `a` is still close to `L`.\n"
"\n"
"The same `N` works for all subsequences!\n"
"\n"
"**The Contrapositive: A Divergence Test**\n"
"\n"
"The Subsequence Theorem says: *If `a n → L`, then every subsequence converges to `L`.*\n"
"\n"
"By contrapositive: *If there exist two subsequences converging to different limits, then `a` does not converge.*\n"
"\n"
"This is a powerful tool for proving divergence!\n"
"\n"
"**Example Application:**\n"
"\n"
"Consider `a n = (-1)^n`, which oscillates between -1 and 1:\n"
"- The even-indexed subsequence: `a(0), a(2), a(4), ... = 1, 1, 1, ...` converges to 1\n"
"- The odd-indexed subsequence: `a(1), a(3), a(5), ... = -1, -1, -1, ...` converges to -1\n"
"\n"
"Since we have subsequences converging to different limits (1 and -1), the sequence `a n = (-1)^n` does not converge. We'll see this in the next level!\n"
"\n"
"**Looking Ahead:**\n"
"\n"
"Subsequences are fundamental in analysis:\n"
"- **Bolzano-Weierstrass Theorem:** Every bounded sequence has a convergent subsequence\n"
"- **Compactness:** Sequential compactness is defined using subsequences\n"
"- **Cauchy sequences:** Can be understood through subsequences\n"
"- **limsup and liminf:** Defined as limits of monotone subsequences\n"
"\n"
"The concept generalizes to metric spaces and topological spaces, where it's crucial for understanding convergence and compactness.\n"
"\n"
"**Exercise:** Prove that if a sequence has two subsequences converging to different limits, then the sequence diverges. (Hint: use proof by contradiction—assume the sequence converges and derive that the two limits must be equal.)"
msgstr ""

#: Game.Levels.L10Pset.L10Pset7
msgid "Problem 6"
msgstr ""

#: Game.Levels.L13Levels.L03_MonotoneSubseq
msgid "Monotone Subsequence"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Now we need `1 / n < ε`. First establish that everything is positive. Start with: `have f3 : 0 < 1 / ε := by bound`"
msgstr ""

#: Game.Levels.L11Levels.L01_IsCauchyOfLim
msgid "If a sequence `a : ℕ → ℝ` converges, then it is Cauchy."
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "And now the `bound` tactic will do the trick."
msgstr ""

#: Game.Levels.L9Pset.L9Pset3
msgid "# Problem 3\n"
"\n"
"Prove that `2 * (1 + 2 + ... + N) = N * (N + 1)`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "The `intro` tactic introduces variables and hypotheses from ∀ statements or implications."
msgstr ""

#: Game.Levels.L10Pset.L10Pset2
msgid "If sequence `a : ℕ → ℝ` converges to `0` and sequence `b : ℕ → ℝ` is bounded, then `a n * b n` converges to `0`."
msgstr ""

#: Game.Levels.L7Pset.L7Pset2
msgid "# Problem 2\n"
"\n"
"Suppose that sequences `a b : ℕ → ℝ` converge to `L` and `M`, resp, with `L < M`. Show that\n"
"eventually, `a n < b n`."
msgstr ""

#: Game.Levels.L3Pset.L3Pset2
msgid "Prove that the sequence `(n + 1) / n` has a limit `L` and determine what it is."
msgstr ""

#: Game.Levels.L7Levels.L01_Eventually
msgid "## What You've Proven\n"
"\n"
"Excellent work! You've proven that convergent sequences with nonzero limits are\n"
"**eventually bounded away from zero**. This is more than just a technical lemma—it's\n"
"a deep insight about the behavior of convergent sequences.\n"
"\n"
"## The Reverse Triangle Inequality in Action\n"
"\n"
"This proof showcased a powerful technique: using the triangle inequality \"in reverse\"\n"
"to establish lower bounds rather than upper bounds. The key manipulation was:\n"
"\n"
"$$|L| = |a (n) + (L - a (n))| \\leq |a (n)| + |L - a (n)|$$\n"
"\n"
"This allowed us to isolate `|a (n)|` and bound it from below.\n"
"\n"
"## Looking Ahead\n"
"\n"
"This result is the crucial prerequisite for proving that reciprocals preserve convergence.\n"
"When we want to show that `1/a (n) → 1/L`, we need to ensure that the denominators `a (n)`\n"
"don't get too small. This theorem guarantees exactly that: eventually, `|a (n)| ≥ |L|/2 > 0`,\n"
"so the reciprocals `1/a (n)` are well-defined and bounded.\n"
"\n"
"You now have the key tool needed for the next major theorem!"
msgstr ""

#: Game.Levels.L8Pset.L8Pset4
msgid "# Problem 4\n"
"\n"
"Suppose a sequence `σ : ℕ → ℕ` takes values in the\n"
"*natural numbers* (not reals), and is strictly increasing, that is,\n"
"if `i < j`, then `σ (i) < σ (j)`. Prove that\n"
"`σ (n)` grows at least as fast as `n` itself."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "The `linarith` tactic, with syntax `linarith [h₁, h₂]`, can solve goals that are linear arithmetic combinations of hypotheses `h₁, h₂` involving `≤`, `<`, `=` with addition and multiplication by constants.\n"
"- ✅ **Linear:** `2*x + y - 3`, `z / 5`\n"
"- ❌ **Not Linear:** `x*y`, `x^2`, `|x|`, `1/x`\n"
"\n"
"Example Usage:\n"
"h1 : x < y\n"
"h2 : y ≤ z\n"
"Goal: x < z + 1\n"
"linarith [h1, h2]"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "Write `ring_nf` to expand and simplify both sides algebraically."
msgstr ""

#: Game.Levels.L10Levels.L09_Subseq
msgid "Subsequence Example"
msgstr ""

#: Game.Levels.L14Levels.L01_BolzanoWeierstrass
msgid "If a sequence `a : ℕ → X` (where `X` can be `ℚ` or `ℝ`) is antitone and bounded, then it is Cauchy."
msgstr ""

#: Game.Levels.L6PsetIntro
msgid "# Problem Set 6\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "**BIG BOSS LEVEL**: This problem requires all the tactics you've learned!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi
msgid "Lecture 2: Newton's Computation of π"
msgstr ""

#: Game.Levels.L8Pset.L8Pset1
msgid "For all `n : ℕ`, `2 * n + 9 ≤ 2 ^ (n + 4)`."
msgstr ""

#: Game.Levels.L7Levels.L00_Uniqueness
msgid "## What You've Proven\n"
"\n"
"Congratulations! You've just established one of the most important foundational results in\n"
"analysis: **limits are unique**.\n"
"\n"
"This theorem justifies our use of the definite article—we can speak of \"**the** limit\"\n"
"of a sequence rather than \"**a** limit.\" Without uniqueness, the entire theory of limits\n"
"would be ambiguous and potentially inconsistent.\n"
"\n"
"## Why Uniqueness Matters\n"
"\n"
"The uniqueness of limits is fundamental to the entire edifice of analysis. It ensures that:\n"
"\n"
"- When we define continuous functions using limits, the definitions are unambiguous\n"
"- Limit notation like `lim_{n→∞} a(n) = L` is well-defined\n"
"- We can safely use limits in computations without worrying about multiple possible values\n"
"- Many standard theorems that rely on \"the limit\" make sense\n"
"\n"
"## The Power of Contradiction\n"
"\n"
"This proof also showcased the power of **proof by contradiction** (`by_contra`). When\n"
"direct proof seems difficult, assuming the opposite and deriving an impossibility can be\n"
"an elegant and effective strategy. You'll use this technique many times throughout\n"
"analysis.\n"
"\n"
"The key insight was geometric: if two points are separated by distance `d`, then no third\n"
"point can be within distance `d/2` of both. This simple observation, made rigorous through\n"
"epsilon-N arguments, gave us our contradiction."
msgstr ""

#: Game.Levels.L10Pset.L10Pset7
msgid "If a sequence `a : ℕ → ℝ` has two convergent subsequences, `a ∘ σ` converges to `L` and `a ∘ τ` converges to `M ≠ L`, then `a` is not convergent."
msgstr ""

#: Game.Levels.L12Levels.L01_Choose
msgid "## What You've Accomplished\n"
"\n"
"You've mastered a crucial technique for extracting structured objects from existence statements. By using `choose` to convert the Twin Prime Conjecture into concrete functions, then applying orbit construction to make those functions monotonic, you've built a subsequence that is both strictly increasing and preserves the desired property.\n"
"\n"
"## The Power of `choose`\n"
"\n"
"This level revealed how existence statements like `∀ N, ∃ n > N, p n` are actually encoding:\n"
"- A **function** `τ : ℕ → ℕ` that produces witnesses\n"
"- **Proofs** that these witnesses satisfy the required properties\n"
"- The ability to **extract** these hidden structures for further use\n"
"\n"
"The `choose` tactic transforms abstract existence into concrete tools you can manipulate.\n"
"\n"
"## Bridging Existence and Structure\n"
"\n"
"The key insight is the two-step process:\n"
"1. **Extract witnesses** using `choose` to get a function `τ` satisfying the property\n"
"2. **Add structure** using orbit construction to get a subsequence `σ` that's both monotonic and property-preserving\n"
"\n"
"This pattern - *existence → extraction → structuring* - appears throughout advanced mathematics.\n"
"\n"
"## Looking Ahead\n"
"\n"
"You now have all the tools needed for the main theorem of this lecture. In the next level, you'll see this exact `choose` technique applied to extract subsequences from the negation of the Cauchy property. The orbit construction you've mastered will then be used to accumulate gaps and create the contradiction with boundedness.\n"
"\n"
"The ability to extract functions from complex quantified statements, then transform them to have the structure you need, is a fundamental skill in formal mathematics. You've seen how abstract number theory (Twin Prime Conjecture) and concrete analysis (orbit construction) can work together seamlessly."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Clear denominators in the goal: `field_simp`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "Now write `specialize hf t_pos` feed in the proof that `t > 0`; then you should be able to finish it yourself."
msgstr ""

#: Game.Levels.L11Levels.L02_IsCauchyOfSum
msgid "Level 2 : Sums of Cauchy sequences"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "Excellent! You've learned the `choose` tactic for working with existence in hypotheses.\n"
"\n"
"Notice the complete pattern:\n"
"1. `choose c hc using h` unpacked the hypothesis into a specific value `c` and proof `hc : f c = 2`\n"
"2. `use c` provided this same value as our witness for the goal\n"
"3. `rewrite [hc]` rewrote `f c` as `2` in the goal, changing it to `2^2 = 4`\n"
"4. `ring_nf` verified that `2 ^ 2 = 4`\n"
"\n"
"The symmetry is beautiful:\n"
"- `use` when you have `∃` in the goal (\"here's my specific example\")\n"
"- `choose` when you have `∃` in a hypothesis (\"let me unpack this existence claim\")\n"
"\n"
"This completes your basic logical toolkit! In real analysis, you'll use `choose` constantly when working with:\n"
"- Limit definitions (\"given ε > 0, there exists δ > 0...\")\n"
"- Intermediate Value Theorem (\"there exists c such that f(c) = 0\")\n"
"- Existence theorems throughout analysis\n"
"\n"
"You're now ready to tackle real mathematical proofs!"
msgstr ""

#: Game.Levels.L12Lecture
msgid "# Lecture 12: Cauchy Sequences II"
msgstr ""

#: Game.Levels.L3Pset.L3Pset3
msgid "Determine what the limit of the sequence `1 / n ^ 2` is, and prove it."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "Perfect! You've completed your first Lean proof involving real numbers.\n"
"\n"
"Remember: the `apply` tactic is used when you have what you need to prove the goal. Look at the top right: your list of tactics now includes `apply`, and if you forget how it works or what it does, just click on it for a reminder."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "There exists a real number that makes this binomial expansion work."
msgstr ""

#: Game.Levels.L10PsetIntro
msgid "Pset 10"
msgstr ""

#: Game.Levels.L11Lecture
msgid "# Lecture 11: The Real Numbers I\n"
"\n"
"**SOCRATES:** So far we've learned that *if* a sequence converges, then it's bounded, and moreover that any subsequence of it also converges to the same limit.\n"
"\n"
"**SIMPLICIO:** Yeah, so what?\n"
"\n"
"**SOCRATES:** And we saw that there can be sequences which do not themselves converge -- for example, $(-1)^n$ -- but which are bounded and have subsequences that do converge. The even-indexed terms, in this example, are all equal 1.\n"
"\n"
"**SIMPLICIO:** What are you getting at?\n"
"\n"
"**SOCRATES:** Well, what's a question that a mathematician might naturally ask given that information?\n"
"\n"
"**SIMPLICIO:** You mean whether that always happens?\n"
"\n"
"**SOCRATES:** Yes, something like that. Can you elaborate?\n"
"\n"
"**SIMPLICIO:** Okay, I'll play along. You're trying to get me to formulate some kind of converse. If a sequence is bounded, then... it converges? No, that can't be right -- a bounded sequence can bounce around without converging, like $(-1)^n$ itself.\n"
"\n"
"Ah, but maybe there's always *some* subsequence that converges? Hmm, but that can't be right either, since the sequence `aₙ = n` has no convergent subsequence -- it just escapes to infinity.\n"
"\n"
"Oh! But wait, that sequence isn't bounded. Are you saying that if all I know about a sequence is that it's bounded, then there's always *some* subsequence that converges?\n"
"\n"
"**SOCRATES:** Yes, precisely! This important fact is called the \"Bolzano-Weierstrauss theorem\". But here's where it gets **really** subtle. Think about the sequence of fractions: `a (0) = 1 / 1`, `a (1) = 14 / 10`, `a (2) = 141 / 100`, `a (3) = 1414 / 1000`, ... getting closer and closer to $1.4142\\dots = \\sqrt 2$. The sequence is bounded (by $2$, to be crude), and even increasing, but its limit is not a rational number! So the Bolzno-Weierstrauss theorem is not true for the rationals. As I warned you long ago, we'll have to eventually face the fact that we don't even know what the real numbers *are*. I think that time is now.\n"
"\n"
"**SIMPLICIO:** Fine, I'm ready; tell me what they are.\n"
"\n"
"**SOCRATES:** Unfortunately, it's rather complicated, and it'll take us some time to arrive at the answer, and to see why it *is* the answer. Let's take a step back. What would you *like* to be able to say about the real numbers?\n"
"\n"
"**SIMPLICIO:** Well, I guess I'd like to say something like: they're the limits of their decimal expansions. So they're limits of rational sequences. Like, $\\sqrt{2}$ is the limit of that sequence you just mentioned: $1, 1.4, 1.41, 1.414, \\dots$\n"
"\n"
"**SOCRATES:** Good! So you want to define a real number as \"the limit of a sequence of rationals.\" But remind me, what does it mean for a sequence to have a limit?\n"
"\n"
"**SIMPLICIO:** It means that for all `ε > 0`, there exists an `N`, yadda yadda. The terms get arbitrarily close to some number $L$.\n"
"\n"
"**SOCRATES:** And what is this mysterious number $L$? What *type* of number it?\n"
"\n"
"**SIMPLICIO:** It's... a real number. Oh no.\n"
"\n"
"**SOCRATES:** Exactly! We have a circular definition. We're trying to define the real numbers as limits of rational sequences, but the very notion of \"limit\" that we've been using presupposes that we already know what the real numbers are!\n"
"\n"
"**SIMPLICIO:** So we're stuck? We can't define the real numbers?\n"
"\n"
"**SOCRATES:** Sure seems like it! But this is where Cauchy had a **brilliant** insight. He realized the same thing you did: he can't use real numbers to define limits. He wants to say: \"$a_n$ gets closer and closer to $L$\" but without reference to $L$ itself. He needs to find *something else* that he can say $a_n$ gets close to.\n"
"\n"
"**SIMPLICIO:** But he *has* nothing else.\n"
"\n"
"**SOCRATES:** Exactly!! So...?\n"
"\n"
"**SIMPLICIO:** So if all he has is the sequence $a_n$, and he has to compare it to something, and he has nothing else... Oh!!! He has to compare it to **itself**!?! But how?\n"
"\n"
"**SOCRATES:** Wow, you got it! Yes, exactly, How?\n"
"\n"
"**SIMPLICIO:** Well of course it's pointless to ask if `|aₙ - aₙ| < ε`. But... you could ask for `|aₙ - aₘ| < ε`, once `n` and `m` are *both* large enough?\n"
"\n"
"**SOCRATES:** Ha, you did it! Yes, exactly, if $a_n$ and $a_m$ are both within $\\varepsilon$ of **each other**, that should be a substitute for convergence.\n"
"\n"
"**SIMPLICIO:** That's so clever! So instead of saying \"the sequence converges to $L$,\" we say \"the terms of the sequence get arbitrarily close to each other\"?\n"
"\n"
"**SOCRATES:** Precisely. Can you make this formal, using `ε`'s and `N`'s?\n"
"\n"
"**SIMPLICIO:** I think so. I guess we should say that a sequence $a_n$ has a limit if: for every $\\varepsilon > 0$, there exists an $N$ such that for all $m, n \\geq N$, we have $|a_m - a_n| < \\varepsilon$.\n"
"\n"
"**SOCRATES:** Beautiful! But since we already have a different meaning for the notion of  \"has a limit\", we'll call this property \"Cauchy\". So we say that **a sequence is Cauchy** if, as you said:\n"
"\n"
"`∀ ε > 0, ∃ N, ∀ m ≥ N, ∀ n ≥ N, |a m - a n| < ε`\n"
"\n"
"This is one of the most important definitions in **all of mathematics**.\n"
"It appears not only here in real analysis, but also in higher arithmetic when building the p-adic numbers, in functional analysis when studying Banach spaces and Hilbert spaces, and in topology and geometry when \"completing\" metric spaces. Anywhere mathematicians want to talk about  \"convergence\" but without knowing *a priori* where things converge *to*, they reach for a version of Cauchy's definition.\n"
"\n"
"But before we return to the real numbers, let's first get more familiar\n"
"with this definition and what it can do.\n"
"\n"
"**SIMPLICIO:** I like it; let's go!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "The `rewrite` tactic replaces the left-hand side of an equality with the right-hand side in the goal. The syntax is `rewrite [hypothesis_name1, hypothesis_name2, etc]`."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "The `norm_num` tactic can normalize numerical constants and functions of them."
msgstr ""

#: Game.Levels.L4PsetIntro
msgid "Pset 4"
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "Try `use ⌈1 / ε⌉₊ + 1`. Of course you can use other values of `N`, but then I won't be able to give you more hints..."
msgstr ""

#: Game
msgid "A First Course in Real Analysis"
msgstr ""

#: Game.Levels.L10Levels.L07_Order
msgid "# Level 2: Order Limit Theorem\n"
"\n"
"So far we've focused on algebraic operations with limits. Now we explore how limits interact with **inequalities**.\n"
"\n"
"**The Question:** If every term of a sequence satisfies `a n ≤ K`, does the limit also satisfy `L ≤ K`?\n"
"\n"
"The answer is **YES**! Limits preserve weak inequalities. This is intuitive: if a sequence is always below some ceiling `K`, it can't suddenly jump above `K` in the limit.\n"
"\n"
"**New Definition: `SeqBddBy`**\n"
"\n"
"We say a sequence `a` is **bounded by** `M` if `a n ≤ M` for all `n`.\n"
"\n"
"Note the difference:\n"
"- `SeqBdd a`: sequence is bounded (both above and below), i.e., `|a n| ≤ M`\n"
"- `SeqBddBy a M`: sequence is bounded **above** by `M`, i.e., `a n ≤ M`\n"
"\n"
"**The Theorem:** If `a n → L` and `a n ≤ K` for all `n`, then `L ≤ K`.\n"
"\n"
"**Proof Strategy: Contradiction!**\n"
"\n"
"Assume `L > K`. Then `L - K > 0`. Use this as your `ε` in the definition of convergence:\n"
"- There exists `N` such that `|a N - L| < L - K`\n"
"- This means `a N > L - (L - K) = K`\n"
"- But we know `a N ≤ K` by hypothesis\n"
"- **Contradiction!**\n"
"\n"
"The key insight: if the limit were strictly above `K`, then eventually the terms would have to be above `K` too (by convergence). But they're not!\n"
"\n"
"**Warning:** Strict inequalities are NOT preserved! If `a n < K` for all `n`, we can only conclude `L ≤ K`, not `L < K`.\n"
"\n"
"Example: `a n = 1/n` satisfies `a n > 0` for all `n`, but `lim a n = 0`, which is not strictly positive.\n"
"\n"
"This theorem can also be used to prove the **Squeeze Theorem** (which we already did directly)."
msgstr ""

#: Game.Levels.L12Levels.L00_SubseqIterate
msgid "For a function `σ : ℕ → ℕ`, we have that: `σ (σ^[k]) = σ^[k+1]`."
msgstr ""

#: Game.Levels.L7Levels.L03_SeqInvLim
msgid "## Congratulations, Big Boss Defeated!\n"
"\n"
"You've just completed one of the most challenging proofs in elementary analysis! The\n"
"reciprocal limit theorem is a major milestone—you've proven that reciprocals preserve\n"
"convergence (when the limit is nonzero).\n"
"\n"
"## What You Accomplished\n"
"\n"
"This proof required you to orchestrate multiple sophisticated techniques:\n"
"- Using `EventuallyGeHalfLim` to ensure denominators stay bounded away from zero\n"
"- Choosing a carefully calibrated epsilon (`ε · |L|² / 2`) to make the algebra work\n"
"- Manipulating complex fractional expressions with common denominators\n"
"- Applying `abs_div` to separate absolute values across division\n"
"- Chaining together a sequence of inequalities to reach the final bound\n"
"\n"
"Each step built on the previous levels, showing how mathematical proofs are constructed\n"
"from carefully assembled building blocks.\n"
"\n"
"## Applications and Extensions\n"
"\n"
"With this theorem in hand, you now have a complete toolkit for limits of **rational\n"
"functions**. Combined with earlier results on sums and products, you can now prove:\n"
"\n"
"**If `a n → L` and `c n → M` with `M ≠ 0`, then `a n / c n → L / M`.**\n"
"\n"
"The proof is straightforward: first show `1/c n → 1/M` using the reciprocal theorem you\n"
"just proved, then use the product theorem to show `a n · (1/c n) → L · (1/M) = L/M`.\n"
"\n"
"This completes the fundamental arithmetic of limits: sums, products, and quotients. These\n"
"are the building blocks for analyzing limits of polynomials, rational functions, and much\n"
"more complex expressions throughout calculus and analysis.\n"
"\n"
"## Mastery of Technique\n"
"\n"
"The reciprocal theorem showcases a crucial lesson in mathematical proof: sometimes the\n"
"\"right\" epsilon isn't the obvious choice. The expression `ε · |L|² / 2` might seem\n"
"mysterious at first, but it's precisely engineered to make the final inequalities work out.\n"
"This kind of strategic thinking—working backwards from what you need to figure out what\n"
"you should assume—is at the heart of mathematical problem-solving.\n"
"\n"
"You've now mastered the essential techniques for proving limit theorems. Well done!"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Presumably you know that you\n"
"should `choose N hN using f1` at this stage. But maybe you'd like to give `hN` a more descriptive name (so that I can keep giving you hints). Try `choose N eps_inv_lt_N using f1`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "The choose tactic"
msgstr ""

#: Game
msgid "An Introduction to (Formal) Real Analysis"
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
#: Game.Levels.L2Pset.L2Pset2
#: Game.Levels.L3Pset.L3Pset2
#: Game.Levels.L6Pset.L6Pset2
#: Game.Levels.L7Pset.L7Pset2
#: Game.Levels.L8Pset.L8Pset2
#: Game.Levels.L9Pset.L9Pset2
#: Game.Levels.L10Pset.L10Pset3
#: Game.Levels.L12Pset.L12Pset2
msgid "Problem 2"
msgstr ""

#: Game.Levels.L8Levels.L03_Induction'
msgid "# Level 1: Induction\n"
"\n"
"In this level, you'll prove your first theorem by mathematical induction: for all natural numbers `n`, we have `n < 2^n`. This captures the fundamental fact that exponential functions grow faster than linear functions.\n"
"\n"
"## Proof Strategy\n"
"\n"
"The proof follows the standard induction template:\n"
"\n"
"**Base Case (`n = 0`):** Show that `0 < 2^0 = 1`. This is straightforward.\n"
"\n"
"**Inductive Step:** Assume `k < 2^k` (the inductive hypothesis `hk`). Prove that `k + 1 < 2^(k+1)`.\n"
"\n"
"The key challenge is connecting `k + 1` to `2^(k+1) = 2 · 2^k`. While the inductive hypothesis gives us `k < 2^k`, we need to show `k + 1 < 2 · 2^k`.\n"
"\n"
"If we can show that `k + 1 ≤ 2k`, then we'd have:\n"
"\n"
"`k + 1 ≤ 2k < 2 · 2^k = 2^(k+1)`\n"
"\n"
"However, `k + 1 ≤ 2k` is only true when `k ≥ 1`. This means you'll need to handle two cases in the inductive step:\n"
"- When `k = 0`: Check directly that `1 < 2`\n"
"- When `k ≠ 0`: Use the inequality `k + 1 ≤ 2k`\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"### `induction'`\n"
"The syntax for induction is: `induction' n with k hk`\n"
"- Apply induction on the variable `n`\n"
"- Use `k` as the dummy variable in the inductive step\n"
"- Use `hk` as the name for the induction hypothesis\n"
"\n"
"This creates two goals:\n"
"1. **Base case:** Prove the statement for `n = 0`\n"
"2. **Inductive step:** With hypothesis `hk : (statement for k)`, prove the statement for `k + 1`\n"
"\n"
"### `ge_one_of_nonzero`\n"
"If `n : ℕ` and `n ≠ 0`, then `1 ≤ n`. Apply this with `apply ge_one_of_nonzero` when you have a hypothesis that `n ≠ 0`.\n"
"\n"
"## Hints\n"
"\n"
"- Use `induction' n with k hk` to begin\n"
"- The base case should be handled with `norm_num`\n"
"- In the inductive step, use `by_cases hk0 : k = 0` to split into two cases\n"
"- When `k = 0`, use `rewrite [hk0]` and `norm_num`\n"
"- When `k ≠ 0`, use `ge_one_of_nonzero` to get `1 ≤ k`, then build a chain of inequalities with `bound` and `linarith`\n"
"- Use `ring_nf` to simplify `2 * 2^k = 2^(k+1)`"
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "# Problem 2\n"
"\n"
"In this problem you are asked to show that there is some `c` so that `(x + y) ^ 2 = c`, given that\n"
"`x * y = 1` and `x ^ 2 + y ^ 2 = 2`.\n"
"\n"
"You will likely have a hard time solving this problem as is.\n"
"You surely can work out what value of\n"
"`c` you need. But if you try\n"
"`ring_nf`, you won't have control over\n"
"how the \"normal form\" chooses to\n"
"express things. In fact, the\n"
"left-hand side, `(x + y) ^ 2` will\n"
"turn into `x * y * 2 + x ^ 2 + y ^ 2`,\n"
"which is parsed in this order:\n"
"\n"
"`(((x * y) * 2) + x ^ 2) + y ^ 2`\n"
"\n"
"This means that you *will* be able to\n"
"`rewrite [h2]` successfully,\n"
"but then you will *not* be able to rewrite by `h1`, because the (invisible) parentheses  go the wrong way. (Hint: If you want to know how things are grouped but don't see parentheses, you can hover your cursor over the text in the Goal State, and Lean will show you the groupings. Try it!)\n"
"\n"
"Now, in natural language, there are times when you might want to\n"
"record an auxiliary fact: \"let's\n"
"*have* the fact that such and such ...\". The Lean\n"
"syntax for this is as follows:\n"
"\n"
"`have NewFactName (Assumptions) : Conclusion := by Proof`\n"
"\n"
"That is, you first write `have`; then give\n"
"the new hypothesis a name; then include any\n"
"assumptions, like `(x : ℝ)`, meaning, `x`\n"
"is a real number, etc (the symbol `ℝ` is written with a backslash, then capital `R`, then space); then you put a colon,\n"
"and then state the conclusion; then you\n"
"put a colon-equals and the word `by`; and finally you give the proof.\n"
"\n"
"For example, if you wanted to declare\n"
"the new fact that, say, for any real `u` and `v`,\n"
"\n"
"`(u + v) ^ 2 = (u ^ 2 + v ^ 2) + 2 * (u * v)`\n"
"\n"
"and you wanted to call this fact `huv` (a hypothesis on `u` and `v`),\n"
"and you wanted to prove this fact by\n"
"invoking the ring normal form tactic,\n"
" then you would give Lean the command:\n"
"\n"
"`have huv (u v : ℝ), (u ^ 2 + v ^ 2) + 2 * (u * v) := by ring_nf`\n"
"\n"
"This will add to your list of hypotheses\n"
"the fact: `huv : ∀ (u v : ℝ), (u ^ 2 + v ^ 2) + 2 * (u * v)`.\n"
"\n"
"Something like this (if not exactly this)\n"
"will be useful to you in solving this problem."
msgstr ""

#: Game.Levels.L13PsetIntro
msgid "# Problem Set 13\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Combine everything with `linarith [eps_inv_lt_N, f4]`"
msgstr ""

#: Game.Levels.L8Lecture
msgid "# Lecture 8: Mathematical Induction\n"
"\n"
"**SIMPLICIO:** Hey Socrates, I've been thinking about something that's been bothering me. When we prove things in mathematics, we usually prove a specific statement. But what if I want to prove something is true for *all* natural numbers? Like, how do I prove a statement for 0, 1, 2, 3, 4, and so on... forever?\n"
"\n"
"**SOCRATES:** Ah, an excellent question! You're right that we can't just check each case one by one—that would take infinitely long. Tell me, Simplicio, have you ever climbed a ladder?\n"
"\n"
"**SIMPLICIO:** Of course! What does that have to do with anything?\n"
"\n"
"**SOCRATES:** Well, imagine an infinitely tall ladder reaching up to the sky. If I wanted to convince you that you *could* climb to any rung on this ladder, what would I need to show you?\n"
"\n"
"**SIMPLICIO:** Hmm... I guess you'd need to show me that I can reach the bottom-most rung?\n"
"\n"
"**SOCRATES:** Good start! And what else?\n"
"\n"
"**SIMPLICIO:** Well, if I'm standing on any particular rung, I'd need to know I can reach the next one up. So if I can always step from one rung to the next...\n"
"\n"
"**SOCRATES:** Exactly! So if you can reach the first rung, and you can always step from rung `k` to rung `k+1`, then what can you conclude?\n"
"\n"
"**SIMPLICIO:** Oh! Then I can reach *any* rung I want! If I want to reach rung 100, I just start at rung 0, step to rung 1, then to rung 2, and keep going until I reach rung 100. And the same works for any number!\n"
"\n"
"**SOCRATES:** Precisely! This is the essence of **mathematical induction**. To prove something is true for all natural numbers `n`, you need exactly two things:\n"
"- A **base case**: prove it's true for `n = 0`\n"
"- An **inductive step**: prove that *if* it's true for `n = k`, *then* it's true for `n = k + 1`\n"
"\n"
"**SIMPLICIO:** Wait, but in the inductive step, aren't we assuming what we're trying to prove? Isn't that circular reasoning?\n"
"\n"
"**SOCRATES:** An astute observation! But no, it's not circular. We're not assuming the statement is true for all `n`. We're only assuming it's true for one particular value `k`, and using that assumption to prove that it's true for `k + 1`. We're proving an implication: \"if `P(k)` then `P(k+1)`\". Combined with the base case, this creates a chain reaction that reaches any natural number.\n"
"\n"
"**SIMPLICIO:** Hmm, I think I see. So the assumption \"it's true for `k`\" is called the inductive hypothesis?\n"
"\n"
"**SOCRATES:** Exactly! And that hypothesis is your most powerful tool. It's like having a foothold on rung `k` that you can push off from to reach rung `k + 1`.\n"
"\n"
"**SIMPLICIO:** But why does this work? I mean, why should I believe this principle?\n"
"\n"
"**SOCRATES:** Ah, a deep question! It comes from the very definition of the natural numbers themselves. How do you think the natural numbers are constructed?\n"
"\n"
"**SIMPLICIO:** Well... I guess we start with 0. And then we have 1, which is 0 + 1. And 2 is 1 + 1. So each number is the \"successor\" of the previous one?\n"
"\n"
"**SOCRATES:** Beautiful! The natural numbers are defined by exactly this process:\n"
"- Zero is a natural number\n"
"- If `k` is a natural number, then `k + 1` is also a natural number\n"
"- These are the *only* natural numbers\n"
"\n"
"Do you see how this mirrors the structure of induction?\n"
"\n"
"**SIMPLICIO:** Oh wow! The base case corresponds to \"zero is a natural number,\" and the inductive step corresponds to \"if `k` is a natural number, then so is `k + 1`.\" Induction is just the construction of the natural numbers turned into a proof technique!\n"
"\n"
"**SOCRATES:** Precisely! There are no \"gaps\" in the natural numbers—no number that can't be reached by starting at 0 and repeatedly adding 1. This is why induction works.\n"
"\n"
"In fact, this is not just a philosophical observation—this is *literally* how the natural numbers are implemented in Lean! In Lean's type theory, a natural number is defined inductively as either:\n"
"- `zero : ℕ`, the base case, or\n"
"- `succ n : ℕ`, the successor of another natural number `n`\n"
"\n"
"Here's how this looks in the core of Lean:\n"
"\n"
"`inductive Nat where`\n"
"- `| zero : Nat`\n"
"- `| succ (n : Nat) : Nat`\n"
"\n"
"You simply declare the existence of a natural number called `zero`, and then we declare that, given any natural number `n`, there's another one called `succ n`. (The word `succ` is here just a name for this constructor; we could have called it `Alice` instead. The important thing is that we're giving a way to construct a new natural number from a previously existing one.)\n"
"\n"
"So the number 3, for instance, is literally represented as `succ (succ (succ zero))`. The principle of induction doesn't just *resemble* this construction, it directly exploits it! When you prove something by induction in Lean, you're working with the actual computational structure of how natural numbers exist in the system.\n"
"\n"
"**SIMPLICIO:** That's amazing! So induction isn't just a proof technique—it's baked into the very fabric of how Lean understands numbers?\n"
"\n"
"**SOCRATES:** Exactly. The principle of mathematical induction is a theorem in many mathematical frameworks, but in type theory, it's a fundamental consequence of how the natural numbers are defined.\n"
"\n"
"**SIMPLICIO:** Okay, I'm convinced this is a legitimate proof technique. Can you give me an example?\n"
"\n"
"**SOCRATES:** Certainly."
msgstr ""

#: Game.Levels.L3Pset.L3Pset1
msgid "# Problem 1\n"
"\n"
"The \"full\" Archimedean Property is this:\n"
"Take two positive real numbers `x` and `y`. No matter\n"
"how large `y` may be, and how small `x` may be,\n"
"if we add `x` to itself enough times (that is, multiply it by some natural number), we can always get that to exceed `y`."
msgstr ""

#: Game.Levels.L3Pset.L3Pset4
msgid "Usage: given hypothesis `h : 0 ≤ X`, you can prove: `have : |X| = X := by apply abs_of_nonneg h`"
msgstr ""

#: Game.Levels.L6Levels.L06_Squeeze
msgid "If `a c : ℕ → ℝ`, with `a` and `c` both converging to `L`,\n"
"and `b` is another sequence, squeezed between `a` and `c`, then `b` also converges to `L`."
msgstr ""

#: Game.Levels.L13Pset.L13Pset1
msgid "# Problem 1:\n"
"\n"
"Prove `AntitoneSubseq_of_UnBddPeaks`\n"
"\n"
"## New theorem: `Antitone_of_succ`"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Start by converting to the definition of sequential convergence using `change`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "Write `apply h` since the hypothesis `h` is  what we want to prove."
msgstr ""

#: Game.Levels.L11Levels.L02_IsCauchyOfSum
msgid "# Level 2: Sums of Cauchy Sequences\n"
"\n"
"Now that we know convergent sequences are Cauchy, let's explore how Cauchy sequences behave under arithmetic operations. Just like we proved that sums of convergent sequences converge, we'll show that sums of Cauchy sequences are Cauchy.\n"
"\n"
"This theorem is important because it shows that the Cauchy property is preserved by addition—a crucial fact we'll need when we eventually define the real numbers!\n"
"\n"
"## The Setup\n"
"\n"
"Given:\n"
"- `a : ℕ → ℝ` is Cauchy\n"
"- `b : ℕ → ℝ` is Cauchy\n"
"\n"
"Prove: `a + b` is Cauchy\n"
"\n"
"## Strategy\n"
"\n"
"This proof follows a familiar pattern from the sum of limits theorem:\n"
"\n"
"1. **Split epsilon**: Apply the Cauchy property to both `a` and `b` using `ε/2`\n"
"2. **Take the maximum N**: Use `N₁ + N₂` to ensure both Cauchy conditions hold\n"
"3. **Change the goal**: Express `|(a + b)ₘ - (a + b)ₙ|` as `|(aₘ - aₙ) + (bₘ - bₙ)|`\n"
"4. **Triangle inequality**: Split the sum into two pieces\n"
"5. **Combine estimates**: Each piece is less than `ε / 2`, so the total is less than `ε`\n"
"\n"
"## Key Insight\n"
"\n"
"The beauty of the Cauchy property is that we don't need to know *where* the sequences converge—we only need to know that their terms get close to *each other*. This self-referential definition makes the proof very similar to the sum of limits, but without ever mentioning a limit!\n"
"\n"
"Let's prove it!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "# Algebraic manipulations\n"
"\n"
"Now let's learn about algebraic simplification. Suppose you need to prove that $(x + y)^3 = x^3 + 3x^2y + 3xy^2 + y^3$.\n"
"\n"
"This is true by the basic laws of algebra - expanding the left side using the distributive law, commutativity, associativity, etc. But doing this by hand would be extremely tedious.\n"
"\n"
"Fortunately, Lean has a powerful tactic called `ring_nf` (\"ring normal form\") that can automatically perform algebraic manipulations like:\n"
"- Expanding products\n"
"- Collecting like terms\n"
"- Rearranging using commutativity and associativity\n"
"- Applying the distributive law\n"
"\n"
"When you have an algebraic identity involving addition, subtraction, and multiplication, `ring_nf` can often prove it automatically.\n"
"\n"
"Try it out on this classic binomial expansion!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "Type `rewrite [Bob]` to replace `x` with `2` in the goal. Then what?"
msgstr ""

#: Game.Levels.L1RealAnalysisStory
msgid "Lecture 1: The Story of Real Analysis"
msgstr ""

#: Game.Levels.L2Pset.L2Pset1
#: Game.Levels.L2Pset.L2Pset2
msgid "Find the correct constant."
msgstr ""

#: Game.Levels.L12Levels.L00_SubseqIterate
msgid "Iterated Subsequence"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "Great! You've learned the `rewrite` tactic.\n"
"\n"
"Notice what happened: after you typed `rewrite [Bob]`, the goal changed from `x + y = 2 + y` to `2 + y = 2 + y`. Then you needed to type `rfl` to finish the proof, since both sides were now identical.\n"
"\n"
"So far you've learned:\n"
"- `apply hypothesis_name` when a hypothesis matches your goal\n"
"- `rfl` when you need to prove something equals itself\n"
"- `rewrite [hypothesis_name]` when you want to use an equality to rewrite your goal\n"
"\n"
"The `rewrite` tactic is incredibly powerful and you'll use it constantly in real analysis!"
msgstr ""

#: Game.Levels.L9Lecture
msgid "Lecture 9: Algebraic Limit Theorem, Part IV"
msgstr ""

#: Game.Levels.L11Levels.L03_IsBddOfCauchy
msgid "# Outstanding! You've proven that Cauchy sequences are bounded!\n"
"\n"
"This was a challenging proof involving case analysis, finite sums, and careful bookkeeping—but you did it! You've shown that the self-referential Cauchy property is powerful enough to guarantee boundedness.\n"
"\n"
"## What you've accomplished\n"
"\n"
"You've now proven that Cauchy sequences share two key properties with convergent sequences:\n"
"1. **They're bounded** (this level)\n"
"2. **They're closed under addition** (previous level)\n"
"\n"
"And you did all this **without ever mentioning where they converge**!\n"
"\n"
"## Why this matters\n"
"\n"
"This theorem is absolutely crucial for the theory of real numbers:\n"
"\n"
"- In the rationals `ℚ`, there are Cauchy sequences that don't converge (like the decimal approximations to `√2`)\n"
"- But they're still *bounded*, which means they're not escaping to infinity\n"
"- This boundedness will be essential when we prove the **Bolzano-Weierstrauss theorem**: every bounded sequence has a convergent subsequence\n"
"- Eventually, we'll use these facts to show that in `ℝ` (but not in `ℚ`), every Cauchy sequence *does* converge—this is called **completeness**\n"
"\n"
"## The technique you mastered\n"
"\n"
"The key technique here was splitting into cases:\n"
"- **Finitely many terms** (`m < N`): Handled by taking a maximum\n"
"- **Infinitely many terms** (`m ≥ N`): Handled by the Cauchy property\n"
"\n"
"This \"finite + infinite\" splitting technique appears throughout analysis!\n"
"\n"
"## Looking ahead\n"
"\n"
"You've now built up the basic theory of Cauchy sequences. Next, we'll start connecting this back to the real numbers and exploring what it means for ℝ to be **complete**—the property that makes real analysis work!\n"
"\n"
"Congratulations on completing this lecture!"
msgstr ""

#: Game.Levels.L10Pset.L10Pset3
msgid "If sequences `a b : ℕ → ℝ` converge with `a` going to `L` and `b` going to `M`, then `a n * b n` converges to `L * M`."
msgstr ""

#: Game.Levels.L7Levels.L01_Eventually
msgid "# Level 2: Eventually—Convergent Sequences Stay Near Their Limits\n"
"\n"
"When a sequence converges to a nonzero limit, it doesn't just get arbitrarily close to\n"
"that limit—it **eventually stays away from zero** as well. This \"eventually bounded away\n"
"from zero\" property is crucial for many theorems involving quotients and reciprocals.\n"
"\n"
"The intuition is straightforward: if a sequence is converging to some nonzero value `L`,\n"
"then eventually the sequence terms must be at least half as large (in absolute value) as\n"
"`L` itself. They can't simultaneously be approaching `L` and shrinking toward zero.\n"
"\n"
"## What We're Proving\n"
"\n"
"**Theorem:** If `a : ℕ → ℝ` converges to `L` with `L ≠ 0`, then there exists `N` such\n"
"that for all `n ≥ N`, we have `|a (n)| ≥ |L| / 2`.\n"
"\n"
"In other words, once `n` is large enough, the sequence stays at least half as far from\n"
"zero as the limit is.\n"
"\n"
"## The Strategy\n"
"\n"
"The key is to use the convergence condition with `ε = |L| / 2`:\n"
"\n"
"1. Since `L ≠ 0`, we have `|L| > 0`, so `ε = |L| / 2` is a valid positive epsilon\n"
"2. Convergence gives us `N` such that `|a (n) - L| < |L| / 2` for all `n ≥ N`\n"
"3. This means `a (n)` is within distance `|L| / 2` of `L`\n"
"4. By the reverse triangle inequality, this forces `|a (n)| ≥ |L| / 2`\n"
"\n"
"The algebraic key is recognizing that:\n"
"$$|L| = |a (n) + (L - a (n))| \\leq |a (n)| + |L - a (n)| < |a (n)| + \\frac{|L|}{2}$$\n"
"\n"
"Rearranging gives us `|a (n)| > |L| / 2`.\n"
"\n"
"## Why This Matters\n"
"\n"
"This result is essential for the next level, where we'll prove that reciprocals of\n"
"convergent sequences converge. We need to know that the denominators don't approach zero,\n"
"which would cause the reciprocals to blow up. This theorem provides exactly that guarantee!"
msgstr ""

#: Game.Levels.L6Lecture
msgid "# More on sequences\n"
"\n"
"Welcome to Lecture 6, where we continue our deep dive into the fundamental theorems of real analysis.\n"
"\n"
"This lecture focuses on two essential aspects of mathematical reasoning: **logical structure** and **practical techniques**. You'll master the fundamental logical operations that appear everywhere in mathematics—working with \"and\" statements, \"or\" statements, and the connections between them. These aren't just abstract logical exercises; they're the building blocks that make complex proofs manageable and clear.\n"
"\n"
"**What You'll Accomplish:**\n"
"\n"
"First, you'll develop fluency with Lean's logical tactics: constructing conjunctions with `split_ands`, making strategic choices with `left` and `right`, extracting information with dot notation, and handling case analysis with `cases'`. These form a complete toolkit for navigating the logical landscape of mathematical proof.\n"
"\n"
"Then you'll apply these tools to prove one of the most elegant and powerful results in analysis: the **Squeeze Theorem**. This theorem beautifully demonstrates how logical reasoning and analytical insight combine to create mathematical magic. When you trap a sequence between two others that converge to the same limit, the trapped sequence has no choice but to converge there too!\n"
"\n"
"**The Mathematical Journey:**\n"
"\n"
"You'll see how the abstract logical operations you learn connect directly to concrete analytical reasoning. The same `split_ands` technique that helps you break down complex goals will help you extract bounds from convergence conditions. The `abs_lt` theorem will bridge the gap between absolute value statements and ordinary inequalities, giving you the tools to work with epsilon-N definitions effectively.\n"
"\n"
"By the end of this lecture, you'll have not just learned individual techniques, but gained the ability to orchestrate them in sophisticated mathematical arguments. You're building the foundation for all of real analysis—and developing the logical clarity that distinguishes excellent mathematical reasoning from merely correct calculations.\n"
"\n"
"Let's begin this journey from logical fundamentals to analytical mastery!"
msgstr ""

#: Game.Levels.L8Lecture
msgid "Lecture 8: Induction"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "Perfect! You've learned the `use` tactic for existence proofs.\n"
"\n"
"Notice what happened:\n"
"1. `use 6` told Lean that $c = 6$ is our proposed value\n"
"2. The goal changed to proving $(x + y)^4 = x^4 + 4x^3y + 6x^2y^2 + 4xy^3 + y^4$\n"
"3. `ring_nf` verified that this algebraic identity is correct\n"
"\n"
"The `use` tactic is fundamental in real analysis. You'll need it to:\n"
"- Find specific values of $\\varepsilon$ and $\\delta$ in limit proofs\n"
"- Construct witnesses for existence theorems\n"
"- Provide counterexamples\n"
"\n"
"Your growing toolkit:\n"
"- `apply`, `rfl`, `rewrite` for basic equality reasoning\n"
"- `ring_nf` for algebraic manipulation\n"
"- `use` for existence proofs"
msgstr ""

#: Game.Levels.L8PsetIntro
msgid "Pset 8"
msgstr ""

#: Game.Levels.L8Levels.L03_Induction'
msgid "## Your First Induction Proof Complete!\n"
"\n"
"You've successfully proven that `n < 2^n` for all natural numbers using mathematical induction. This demonstrates a fundamental principle: exponential functions grow faster than linear functions.\n"
"\n"
"## What You Learned\n"
"\n"
"This proof introduced several key techniques:\n"
"\n"
"**Combining Proof Methods:** You used `induction'` as the overall structure, but within the inductive step, you needed `by_cases` to handle different scenarios. This is a common pattern: induction provides the framework, but you often need other tactics to complete the argument.\n"
"\n"
"**Handling Edge Cases:** The `k = 0` case required separate treatment because the inequality `k + 1 ≤ 2k` doesn't hold when `k = 0`. Recognizing when to split cases is an essential skill in mathematical proof.\n"
"\n"
"**Building Inequality Chains:** In the `k ≠ 0` case, you constructed a chain of inequalities: `k + 1 ≤ 2k < 2 · 2^k = 2^(k+1)`. Using the inductive hypothesis `k < 2^k` along with `1 ≤ k` allowed you to bridge from `k + 1` to `2^(k+1)`.\n"
"\n"
"## The Power of Induction\n"
"\n"
"Mathematical induction is one of the most versatile proof techniques. It's essential for:\n"
"- Proving formulas like `∑(i=1 to n) i = n(n+1)/2`\n"
"- Establishing inequalities involving factorials, exponentials, and recursive sequences\n"
"- Verifying properties of recursively defined structures\n"
"- Proving algorithm correctness in computer science\n"
"\n"
"## Key Insight\n"
"\n"
"The key insight to remember: induction transforms an infinite problem (proving something for all `n`) into two finite problems (the base case and the inductive step). Master this technique, and you'll have access to a vast collection of provable theorems."
msgstr ""

#: Game.Levels.L3Lecture
msgid "Lecture 3: More fun with Sequences"
msgstr ""

#: Game.Levels.L5Lecture
msgid "Lecture 5: Algebraic Limit Theorem, Part I"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "Write `specialize hf t` to apply the universal statement to the specific value t."
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "# A Great Debate\n"
"\n"
"In the 19th century, when people were still confused about limits in general, there was a specific sequence that they fought over:\n"
"\n"
"1, -1, 1, -1, 1, -1, ...\n"
"\n"
"Does this converge or not???\n"
"\n"
"Some people said, well, you go up one then down one, so on average, it's around zero. So the limit should be 0.\n"
"\n"
"Other people said: look at the partial sums of the sequence:\n"
"\n"
"1 = 1\n"
"\n"
"1 + (-1) = 0\n"
"\n"
"1 + (-1) + 1 = 1\n"
"\n"
"1 + (-1) + 1 + (-1) = 0\n"
"\n"
"Ah so the partial sums alternate between 1 and 0, so maybe the limit is 1/2!\n"
"\n"
"This is the kind of trouble you get into if you don't have a community consensus on what the definitions of things are, namely, if you don't have a rigorous definition of limit. Luckily, we now do!\n"
"\n"
"With that definition, this sequence .... does not have a limit (\"diverges\").\n"
"\n"
"In order to express that formally, let's make a new definition:\n"
"\n"
"`def SeqConv (a : ℕ → ℝ) : Prop := ∃ L, SeqLim a L`\n"
"\n"
"That is, a sequence `a` \"converges\" (without specifying to what), if there indeed exists some real number `L`\n"
"so that `a` converges to that number.\n"
"\n"
"In this level, then, our goal is to prove:\n"
"\n"
"`Goal : ¬ SeqConv a`,\n"
"\n"
"given the assumption `ha : ∀ n, a n = (-1 : ℝ) ^ n`. (Note that the \"not\" symbol, `¬`, is obtained by typing\n"
"`\\not`.)\n"
"\n"
"How do you prove the negation of something? Logically speaking, you would say, well, if that thing did happen, then we'd have a contradiction. Technically, `¬ P` is definitionally equivalent to: `P → False`.\n"
"\n"
"So we could start our proof by reminding ourselves of this fact, by typing:\n"
"\n"
"`change SeqConv a → False`\n"
"\n"
"That will change the Goal to: `SeqConv a → False`.\n"
"\n"
"In general, I would recommend the following protocol:\n"
"\n"
"1) Think. Do scratchwork, get a vague sense of how to piece the argument together.\n"
"\n"
"2) Then prove it formally. You're NOT done! Just because you proved it formally doesn't *necessarily* mean that you really understand what's going on! The goal of mathematics is *not* that it just works, but rather that you **understand** exactly what's going on. So step 3 is:\n"
"\n"
"3) Give a natural language proof that explains (to yourself, as much as to anyone else, including me) what's going on and why.\n"
"\n"
"Using only knee jerk reactions (if you see `P → Q` in the Goal, write `intro`. If you see `∃` in a hypothesis, write `choose`. If you see a definition in the Goal or a hypothesis, write `change`), we got as far as:\n"
"\n"
"**Objects:** `a : ℕ → ℝ`, `L : ℝ`\n"
"\n"
"**Assumptions:** `ha : ∀ (n : ℕ), a n = (-1) ^ n`, `hL : ∀ ε > 0, ∃ N, ∀ n ≥ N, |a n - L| < ε`\n"
"\n"
"**Goal:** `False`\n"
"\n"
"Remember the Engineer and Mechanic: the Engineer gets to specify any tolerance, and the Mechanic has to guarantee that we'll be within that tolerance \"eventually\", that is, for all large enough `n`, as measured by the lower bound `N`.\n"
"\n"
"**Key Idea:** Find an `ε` that is too tight a tolerance, and the Mechanic will never be able to get within that specification. Because the sequence alternates between `1` and `-1`, which differ by `2`, the tolerance `ε = 1` would already be enough, but just to be safe, let's give ourselves a little more room, and set `ε = 1/2`.\n"
"\n"
"Note: Had we set `ε = 1.5`, that would *not* work. We can't rule out the possibility that `L= 0`, and both values `1` and `-1` *are* indeed within that tolerance. So we won't find a contradiction that way.\n"
"\n"
"\n"
"After a bunch of computation, we reached the following:\n"
"\n"
"`|1 - L| < 1/2`\n"
"\n"
"and\n"
"\n"
"`|-1 - L| < 1/2`\n"
"\n"
"Let's try to come up with a contradiction from that.\n"
"\n"
"`2 = |2| = |1 - (-1)| = |(1 - L) + (L - (-1))|`\n"
"\n"
"`≤|(1 - L)| + |(L - (-1))| = |(1 - L)| + |-((-1) - L)|`\n"
"\n"
"`= |(1 - L)| + |((-1) - L)| < 1/2 + 1/2 = 1`\n"
"\n"
"And that get us the desired contradiction.\n"
"\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"- **Negation**: If `P` is some `Prop`, then `¬ P` is definitionally equivalent to `P → False`. So you can write `change P → False`, either at the Goal, or `at` a hypothesis.\n"
"\n"
"\n"
"- **The triangle inequality**: To add the fact that `|x + y| ≤ |x| + |y|` to our list of hypotheses, invoke the `abs_add` theorem:\n"
"\n"
"`have factName : |x + y| ≤ |x| + |y| := by apply abs_add`\n"
"\n"
"- **Negation inside an absolute value**: You may also find useful the theorem `abs_neg`, which can be called via:\n"
"\n"
"`have factName : |-x| = |x| := by apply abs_neg`\n"
"\n"
"Warning! Make sure the pattern `|-Something|` is on the left hand side. If Lean doesn't see an absolute value\n"
"followed by a minus sign, `abs_neg` won't work!"
msgstr ""

#: Game.Levels.L7Levels.L01_Eventually
msgid "If `a : ℕ → ℝ` converges to `L` and `L ≠ 0`, then there is an `N` so that\n"
"for all `n ≥ N`, `|a (n)| ≥ |L| / 2`."
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "# 🎉 Brilliant Work! 🎉\n"
"\n"
"You've mastered your first true theorem of analysis! Let's celebrate what you accomplished and understand the deeper patterns.\n"
"\n"
"**What you just proved:**\n"
"If a sequence converges to a limit, then any constant multiple of that sequence converges to the constant multiple of the limit. In factory terms: 'If I can meet quality standards, I can also meet those same standards when scaling my output—I just need to be more precise with my inputs!'\n"
"\n"
"**The Elegant Strategy:**\n"
"Your proof used the **inverse scaling** principle:\n"
"1. **Tolerance inversion**: To achieve tolerance ε for doubled output, demand tolerance ε/2 for original input\n"
"2. **Algebraic factoring**: `2 * a n - 2 * L = 2 * (a n - L)` revealed the structure\n"
"3. **Absolute value scaling**: `|2 * x| = |2| * |x|`, followed by `norm_num`, converted the factored form to the needed bound\n"
"4. **Linear arithmetic**: The final `linarith [hN]` combined `2 * |a n - L| < 2 * (ε / 2) = ε`\n"
"\n"
"## Check in, in Natural Language\n"
"\n"
"Let's again step back from the formal Lean proof and understand what we just proved in plain English.\n"
"\n"
"**Theorem (in natural language):** If a sequence of real numbers converges to some limit, then the sequence formed by doubling each term converges to double the original limit.\n"
"\n"
"**Proof:** Suppose sequence $a_n$ converges to $L$, and we want to show that $b_n = 2 \\cdot a_n$ converges to $2L$.\n"
"\n"
"By definition, we need to show that for any tolerance $\\varepsilon > 0$, we can find a point $N$ such that for all $n \\geq N$, we have $|b_n - 2L| < \\varepsilon$.\n"
"\n"
"Here's the key insight: Since $a_n$ converges to $L$, we can make $|a_n - L|$ arbitrarily small. Specifically, we can find an $N$ such that $|a_n - L| < \\varepsilon/2$ for all $n \\geq N$.\n"
"\n"
"Now, for any $n \\geq N$:\n"
"$$|b_n - 2L| = |2a_n - 2L| = |2(a_n - L)| = 2|a_n - L| < 2 \\cdot \\frac{\\varepsilon}{2} = \\varepsilon$$\n"
"\n"
"Therefore, $b_n$ converges to $2L$, completing the proof.\n"
"**QED**\n"
"\n"
"So what do you think? Do you prefer the natural langauge version, or the formal version? (It's a real question! Please tell me.)"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "Big Boss: The Ultimate Tactic Challenge"
msgstr ""

#: Game.Levels.L6Levels.L00_SumOfSeqs
msgid "For two sequences `a b : ℕ → ℝ` and real numbers `L M : ℝ`, with the hypotheses that `SeqLim a L` and `SeqLim b M`, the theorem `SumLim` says that if\n"
"there is a third sequence `c : ℕ → ℝ` so that for all `n`, `c n = a n + b n` (that is, `c` is the sum of the sequences), then `SeqLim c (L + M)` holds."
msgstr ""

#: Game.Levels.L1Pset.L1Pset4
msgid "# Problem 4\n"
"\n"
"This problem looks very similar to the previous one, but without a few hints, it\n"
"may cause great difficulty. The issue is that, last time, you likely called `specialize h1 0`, and turned `h1` into:\n"
"\n"
"`h1 : g (0 + 1) = g (0) + 3`\n"
"\n"
"If you do that now, the original `h1` will be *gone*, and you won't have a way of accessing it *again* to bootstrap from `g (1)` to `g (2)`. So what should you do?\n"
"\n"
"Observe that `have` can perform the same\n"
"role as `specialize` (and much more)! Try starting your solution with:\n"
"\n"
"`have h3 : g (0 + 1) = g (0) + 3 := by apply h1 0`\n"
"\n"
"This will not affect the original statement\n"
"of `h1`, but will instead add a *new* hypothesis, `h3`, which amounts to the\n"
"desired fact that `g (0 + 1) = g (0) + 3`.\n"
"Notice what's happening in the proof: `h1` says: for all `x`, `g (x + 1) = g (x) + 3`.\n"
"So `h1` is really a *function* whose input\n"
"is a real number `x`, and whose output is a\n"
"*proof* of the fact that, for this value of `x`, `g (x + 1) = g (x) + 3` holds. So when\n"
"we feed `0` into `h1`, it has the same effect\n"
"as it did when we `specialize`d, thus giving a proof of\n"
" exactly what was claimed in the `have` statement.\n"
"\n"
"Now you should be able to solve this problem."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings… 🎭"
msgstr ""

#: Game.Levels.L12Levels.L01_Choose
msgid "Enhanced Choose"
msgstr ""

#: Game.Levels.L11Levels.L02_IsCauchyOfSum
msgid "If sequences `a` and `b` are Cauchy, then so is their sum."
msgstr ""

#: Game.Levels.L11Levels.L03_IsBddOfCauchy
msgid "If a sequence `a` is Cauchy, then it is eventually bounded."
msgstr ""

#: Game.Levels.L7Levels.L00_Uniqueness
msgid "Prove that limits are unique."
msgstr ""

#: Game.Levels.L6Levels.L05_AbsLt
msgid "AbsLe"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "# Level 1: The Main Definition\n"
"\n"
"Our first step to making Newton's argument rigorous is\n"
"to spell out *exactly* what we mean by a sequence\n"
"$a_n$ converging. It will take a little work to build up to the definition, and more importantly, *why*\n"
"that might seem like a reasonable definition to have.\n"
"\n"
"But first: for some reason (likely Euler is to blame), mathematics has *two* completely different conventions for how to write functions. For general functions $f : \\mathbb R \\to\\mathbb R$,\n"
"we write $f(x)$, with parentheses. But when work with sequences, $a_n$, meaning,\n"
"$a_0, a_1, a_2, \\dots$, we bizarely switch instead to subscripts.\n"
"Why? Historical accident.\n"
"A sequence is nothing but a function whose \"domain\" (that is, the set of\n"
"inputs to the function) is the natural numbers; so we will break\n"
"with tradition and unify the two conventions, henceforth writing\n"
"$a : \\mathbb N \\to \\mathbb R$ for sequences of real numbers, $a (0), a (1),\n"
"a (2), \\dots$.\n"
"\n"
"Now, the definition that mathematicians eventually came up with\n"
"for what it means for a sequence to converge, was so intricate (at least\n"
"at first sight) that it had to be invented *twice*!\n"
"The eventual formulation crystallized through the work of Karl Weierstrass in the 1860s, who transformed analysis from an intuitive art into a rigorous science. However, the seeds of this idea appeared much earlier in the work of Bernard Bolzano. In the 1810s and 1820s, Bolzano was developing remarkably modern ideas about continuity and limits, but he was too far ahead of his time for the mathematical community to accept these abstract concepts.\n"
"Only by Weierstrass's time -- a half-century later -- did these ideas catch on.\n"
"\n"
"Without further ado, here it is:\n"
"\n"
"Given a sequence `a : ℕ → ℝ` and a real number `L : ℝ`, we\n"
"write `lim a = L` and\n"
"say that the sequence `a` **converges** to `L`,\n"
" if:\n"
"\n"
"For every `ε > 0`, there exists `N : ℕ` such that, for all `n ≥ N`, we have `|a (n) - L| < ε`.\n"
"\n"
"\n"
"This definition is probably not the first, or second, or tenth thing you might've come up with.\n"
"But over time, I hope you'll come to see that it\n"
" embodies a beautiful negotiation between precision and effort.\n"
"\n"
" I like to think of it as a conversation between an Engineer and a Machinist. The Engineer arrives with specifications: 'We're going to make this widget, and I need its length to be 1 foot, with an error tolerance\n"
" of 1/100 of an inch'. The Machinist replies: 'Sure, I can do that, but I'll have to run my special equipment for at least 10 hours to guarantee that tolerance.' The Enginner\n"
" replies: 'I'm sorry, I misspoke, can we change the tolerance\n"
" to 1/1000 of an inch?' The Machinist replies: 'Oof, yeah we can do it, but it'll cost ya. I'll need at least 40 hours of operation, but after that, I'll guarantee it.'\n"
"\n"
"As long as this conversation can continue regardless of *whatever* tolerance `ε > 0` the Engineer requires, with the Machinist\n"
"always being able to reply with a finite minimum number of hours `N`,\n"
"after which the tolerance will be achieved, we can say\n"
"that the equipment **converges**.\n"
"\n"
"Now let's read Weierstrauss's (or is it Bolzano's?) definition again. We have some process\n"
"that at time `n` returns a reading `a (n)` (think: widget length). Our ultimate goal is to make the length `L`. If\n"
"for any tolerance `ε > 0`, no matter how small, there will always exist some minimum\n"
"time `N`, so that, for any future time, `n ≥ N`,\n"
"we are guaranteed to be within that tolerance, `|a (n) - L| < ε`, that's exactly the condition under which we'll\n"
"say that the sequence `a (n)` **converges** to `L`.\n"
"\n"
"[![A Sequence Converging](images/SeqLim.jpg)](https://en.wikipedia.org/wiki/Limit_of_a_sequence)\n"
"\n"
"What makes this definition so powerful is its universality. The Machinist is essentially promising: 'Give me *any* tolerance requirement, no matter how stringent, and I can meet it -- though I might need more resources (larger `N`) for tighter specifications.'\n"
"\n"
"\n"
"Notice something else about the definition: It makes no mention of something happening \"eventually\", or \"at infinity\" or any other wishy-washy squirm words. We have traded the ambiguity of speaking about infinity for the precision of existential and universal quantifiers. No more hand-waving about what happens \"as `n` gets large\" - instead, we have a concrete challenge: given *any* tolerance `ε`, can you find a specific threshold `N`? *That* idea was the key breakthrough that allowed Calculus to enter the realm of rigorous mathematics.\n"
"\n"
"In Lean, the definition is written like so:\n"
"\n"
"`def SeqLim (a : ℕ → ℝ) (L : ℝ) : Prop :=\n"
"  ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, |a n - L| < ε`\n"
"\n"
"This syntax should be familiar from the `have` tactic you already know and love.\n"
"The special symbol `def` (instead of `have`) means that we're about to define something, and\n"
"`SeqLim` is its name (for squence limit, of course; but we could have called it whatever we want). Then our assumptions are a sequence `a : ℕ → ℝ` and\n"
"some real number `L : ℝ`. Then after the colon `:` goes our output, which in this case is `Prop`, that is, a statement (proposition) that can be true or false. So `SeqLim` is really a function that takes a sequence and hypothetical limiting value, and returns true or false based on whether\n"
"the condition is satisfied. Then comes a colon-equals `:=`, after which the\n"
"exact condition to be tested is specified. And the condition is what we already said, for all epsilon, yadda yadda. The big difference is that you can write `have` inside a proof, but you can't write `def` inside a proof;\n"
"`def` is reserved for making global definitions that\n"
"can be referenced forever once they're introduced.\n"
"Notice that on the right hand side, the list\n"
"of Definitions now includes `SeqLim`, and, as usual,\n"
"if you forget what it means, you can click on it for a reminder.\n"
"\n"
"Let's try out the definition in practice!\n"
"\n"
"**Your Task**\n"
"\n"
"Prove that the constant sequence converges to the same constant.\n"
"That is, suppose that you have a sequence `a : ℕ → ℝ`, and there's a real number\n"
"`L`, and a hypothesis that, for all values of `n`, we have  `a (n) = L`; then prove that `a` does converge, and converges to `L`. This is the simplest possible case: if our 'factory' always produces the exact target value `L`, then we can meet any tolerance requirement immediately!\n"
"\n"
"You may find useful a new tactic called `change`. It allows you to replace a goal (or hypothesis) by\n"
"something that is definitionally equal to it. In our example here,\n"
"You will see the goal as `SeqLim a L`. What are you supposed to do with that,\n"
"how can you make progress? Well, if you remember how `SeqLim` is defined,\n"
"then you can replace the goal with the definition, by writing\n"
"\n"
"`change ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, |a n - L| < ε`\n"
"\n"
"Lean will then change the goal to its definition.\n"
"Remember that `ε`, `N`, and `n` are all dummy variables\n"
"here, so you can have some fun:\n"
"\n"
"`change ∀ Alice > 0, ∃ Bob : ℕ, ∀ blah ≥ Bob, |a blah - L| < Alice`\n"
"\n"
"This may come in handy later. (Not Alice and Bob *per se*, but the ability to give better names for dummy variables, so as not to clash with already existing variable names...)\n"
"\n"
"**⚠️⚠️⚠️ CAUTION ⚠️⚠️⚠️** Remember how Lean *must* have space after a function name, it won't accept `f(x)` but instead requires `f (x)`? Well... it's the other way around for absolute\n"
"values. Lean won't accept a space after an absolute value.\n"
"So if you write `| a n - L|`, you'll get an error message.\n"
"Same with `|a n - L |` -- the space at the end is the problem. Sorry! I didn't write the syntax.\n"
"\n"
"**Normalizing Numerical Values**: And one last tactic you might also find useful is `norm_num` (for normalizing numerical values); it evaluates numerical expressions and proves equalities/inequalities involving concrete numbers. For example, if you're stuck with an `|0|` at some point,\n"
"and you want to convert it to plain old `0`, try calling `norm_num`.\n"
"\n"
"Ok, get to it!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "Write `rfl` since we're proving that something equals itself."
msgstr ""

#: Game.Levels.L12Levels.L01_MonotoneBdd
msgid "# Level 3: Monotone and Bounded Implies Cauchy\n"
"\n"
"Now we tackle one of the fundamental theorems of real analysis: every bounded monotone sequence is Cauchy. This result provides a powerful convergence criterion that doesn't require knowing the limit beforehand.\n"
"\n"
"## The Intuitive Picture\n"
"\n"
"Why should this be true? If a sequence is monotone (that is, non-decreasing) and bounded above, then it can't \"escape to infinity\" - there's a ceiling it can't break through. But it also can't have persistent gaps, because each gap would push it a bit higher, and eventually these accumulated jumps would break through the ceiling. So the sequence must \"settle down\" and become Cauchy.\n"
"\n"
"Making this intuition rigorous requires the orbit technique you just mastered.\n"
"\n"
"## A Question of Generality\n"
"\n"
"Before diving in, let's address an important design choice. What type should our sequence have? We could work with `a : ℕ → ℝ` (real sequences), but we're building up to constructing the real numbers, so we shouldn't presuppose their existence. We could use `a : ℕ → ℚ` (rational sequences), but then we'd need to reprove everything for real sequences later.\n"
"\n"
"The elegant solution: work with an abstract type `X` that has just the properties we need. We'll assume `X` has:\n"
"- A linear order (so we can say `x ≤ y`)\n"
"- A norm (so we can say `|x|`)\n"
"- Field operations (so we can add, subtract, multiply, divide)\n"
"- A few other technical properties for the proof to work\n"
"\n"
"Then this theorem automatically applies to both rational and real sequences - Lean will verify that ℚ and ℝ satisfy all our assumptions about `X`.\n"
"\n"
"## Strategic Overview\n"
"\n"
"The proof uses contradiction. We'll assume a bounded monotone sequence is not Cauchy, which means there are persistent gaps of size `ε`. Using the `choose` tactic (as in the previous level), we'll extract subsequences that witness these gaps. Then we'll apply your orbit result to show these gaps accumulate without bound, contradicting the boundedness.\n"
"\n"
"**Your goal:** Prove that if `a : ℕ → X` is monotone and bounded above by `M`, then `a` is Cauchy.\n"
"\n"
"Note: This level uses a \"black box\" helper lemma `IterateGap` that we'll prove in the next level. For now, trust that it captures how gaps accumulate under iteration.\n"
"\n"
"## New Tools\n"
"\n"
"### Definition: `Monotone`\n"
"A sequence `a : ℕ → X` is monotone if `a n ≤ a m` whenever `n ≤ m`.\n"
"\n"
"### Theorem: `Monotone_of_succ`\n"
"To prove monotonicity, it's enough to check consecutive terms: if `a m ≤ a (m+1)` for all `m`, then `a` is `Monotone`.\n"
"\n"
"### Tactic: `push_neg`\n"
"Pushes negations through quantifiers: `¬∀` becomes `∃¬`, `¬∃` becomes `∀¬`, etc. Essential for proof by contradiction with complex statements.\n"
"\n"
"### The Helper Lemma: `IterateGap`\n"
"Given a monotone sequence with persistent gaps of size `ε` between subsequences `τ` and `σ`, the orbit `σ^[k] 0` accumulates at least `k * ε` growth from the starting point. This will be proven in Level 3.\n"
"\n"
"`theorem IterateGap (a : ℕ → X) (ha : Monotone a) (ε : X)\n"
"  (εpos : ε > 0)\n"
"  (τ : ℕ → ℕ) (hτ : ∀ n, τ n ≥ n)\n"
"  (σ : ℕ → ℕ) (hσ : ∀ n, σ n ≥ τ n)\n"
"  (hgap : ∀ n, ε ≤ |a (σ n) - a (τ n)|)\n"
"  : ∀ (k : ℕ), k * ε ≤ a (σ^[k] 0) - a 0\n"
"`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "The rfl tactic"
msgstr ""

#: Game.Levels.L4Lecture
#: Game.Levels.L7Lecture
#: Game.Levels.L9Lecture
msgid "# More on sequences"
msgstr ""

#: Game.Levels.L6Levels.L03_DotNotation
msgid "# 🔍 Information Extraction Mastered! 🔍\n"
"\n"
"Perfect! You've just learned one of the most practical and time-saving techniques in Lean. Dot notation might seem like a small detail, but it's the kind of efficiency that makes complex proofs much more readable and manageable.\n"
"\n"
"**Why This Matters:**\n"
"As mathematical statements become more complex, they often involve multiple conditions or properties. Being able to quickly extract the specific piece of information you need is essential for maintaining clarity in your proofs.\n"
"\n"
"**The Power of Precision:**\n"
"Notice how `h.2` gave us exactly what we needed—no more, no less. This precision is crucial in mathematics, where we want to use exactly the right tool for each step of our argument.\n"
"\n"
"**Looking Forward:**\n"
"As we dive deeper into analysis, you'll encounter hypotheses with multiple convergence conditions, boundedness properties, and continuity requirements all bundled together. Dot notation will be your key to navigating these rich mathematical structures efficiently.\n"
"\n"
"Elegant mathematics isn't just about reaching the right conclusion—it's about getting there with style and clarity. You're building that elegance, one notation at a time."
msgstr ""

#: Game.Levels.L13Lecture
msgid "# Lecture 13: Monotone Subsequence"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "The `specialize` tactic applies a universal statement in a hypothesis to a specific value."
msgstr ""

#: Game.Levels.L6Levels.L01_SplitAnds
#: Game.Levels.L6Levels.L02_LeftRight
#: Game.Levels.L6Levels.L03_DotNotation
#: Game.Levels.L6Levels.L04_Cases'
#: Game.Levels.L6Levels.L05_AbsLt
#: Game.Levels.L6Levels.L06_Squeeze
#: Game.Levels.L7Levels.L01_Eventually
#: Game.Levels.L7Levels.L02_SeqOfAbs
#: Game.Levels.L7Levels.L03_SeqInvLim
#: Game.Levels.L8Levels.L03_Induction'
#: Game.Levels.L9Levels.L04_FiniteSums
#: Game.Levels.L9Levels.L05_BddOfConv
#: Game.Levels.L10Levels.L06_Prod
#: Game.Levels.L10Levels.L07_Order
#: Game.Levels.L10Levels.L08_Mono
#: Game.Levels.L10Levels.L09_Subseq
#: Game.Levels.L10Pset.L10Pset2
#: Game.Levels.L10Pset.L10Pset3
#: Game.Levels.L10Pset.L10Pset4
#: Game.Levels.L10Pset.L10Pset5
#: Game.Levels.L10Pset.L10Pset6
#: Game.Levels.L10Pset.L10Pset7
#: Game.Levels.L11Levels.L01_IsCauchyOfLim
#: Game.Levels.L11Levels.L02_IsCauchyOfSum
#: Game.Levels.L11Levels.L03_IsBddOfCauchy
#: Game.Levels.L11Pset.L11Pset1
#: Game.Levels.L12Levels.L00_SubseqIterate
#: Game.Levels.L12Levels.L01_Choose
#: Game.Levels.L12Levels.L01_MonotoneBdd
#: Game.Levels.L12Pset.L12Pset2
#: Game.Levels.L13Levels.L03_MonotoneSubseq
#: Game.Levels.L14Levels.L01_BolzanoWeierstrass
msgid "Prove this"
msgstr ""

#: Game.Levels.L7Levels.L00_Uniqueness
msgid "# Level 1: Uniqueness of Limits\n"
"\n"
"One of the fundamental properties of convergent sequences is that they converge to a\n"
"**unique** limit. This might seem obvious at first glance—after all, how could a sequence\n"
"be getting arbitrarily close to two different numbers? But as with many intuitive facts\n"
"in analysis, the rigorous proof requires careful reasoning with our epsilon-N definitions.\n"
"\n"
"The key to proving uniqueness is **proof by contradiction**. We'll assume a sequence\n"
"converges to two different limits `L` and `M`, and show this leads to an impossibility.\n"
"The strategy involves choosing epsilon to be half the distance between `L` and `M`, then\n"
"showing the sequence can't simultaneously stay that close to both limits.\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"### Proof by Contradiction: `by_contra`\n"
"\n"
"The `by_contra` tactic allows us to prove a statement by assuming its negation and deriving\n"
"a contradiction. The syntax is `by_contra h`, which adds a hypothesis `h` containing the\n"
"negation of the current goal and changes the goal to `False`.\n"
"\n"
"### `abs_pos_of_nonzero`\n"
"\n"
"If `x ≠ 0`, then `0 < |x|`. This theorem is essential for working with distances between\n"
"distinct points.\n"
"\n"
"## The Strategy\n"
"\n"
"Here's how the proof works:\n"
"\n"
"1. Assume for contradiction that `L ≠ M`\n"
"2. Then `|L - M| > 0`, so we can use `ε := |L - M| / 2` as our tolerance\n"
"3. Apply the convergence condition to get `N₁` and `N₂` for sequences converging to `L` and `M`\n"
"4. Take `N = N₁ + N₂` and evaluate at `n = N`\n"
"5. Use the triangle inequality to show `|L - M| ≤ |a N - L| + |a N - M| < ε + ε = |L - M|`\n"
"6. This gives the contradiction: `|L - M| < |L - M|`\n"
"\n"
"The algebra in step 5 is the key: we write `L - M = (L - a(N)) + (a(N) - M)` and apply\n"
"the triangle inequality to get the impossible conclusion."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi
msgid "# The Mathematical Revolution of 1666\n"
"\n"
"**SIMPLICIO:** I heard that Newton had a really cool way of calculating π. Can you tell me about it?\n"
"\n"
"**SOCRATES:** Certainly. It begins around 1665-1666, when Newton was turning 23 years old. Anything significant about that year?\n"
"\n"
"**SIMPLICIO:** Isn't that Newton's  \"annus mirabilis\",  year of miracles? If I recall correctly, he was forced to leave Cambridge due to an outbreak of  the Great Plague, and made his most groundbreaking discoveries (calculus, optics, gravitation, etc) while quarantining in isolation at his family home in Woolsthorpe.\n"
"\n"
"**SOCRATES:** Exactly right. And one of the first things he discovered in that year was a  new version of\n"
"the Binomial Theorem. Tell me, please,  what can one say about\n"
"$(1 + x) ^ n$?\n"
"\n"
"**SIMPLICIO:** Sure thing, if you multiply $(1+x)^n$ all out, you get\n"
"$ \\binom{n}{0} + \\binom{n}{1}x + \\binom{n}{2}x^2 + \\cdots + \\binom{n}{n}x^n$. Here $\\binom{n}{k}$ is the \"binomial coefficient\", the number of ways of choosing $k$ things from a bag of $n$ things. Explicitly, $\\binom{n}{k} = \\frac{n!}{k! (n-k)!}$. These are just the numbers in Pascal’s Triangle, and you can easily read off the $n$-th row.\n"
"[![Pascal's Triangle](images/Yanghui_triangle.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"\n"
"\n"
"**SOCRATES:** Excellent! And do you know sigma notation?\n"
"\n"
"**SIMPLICIO:** I think so. I could’ve written  that same thing as $\\sum_{k=0}^{n} \\binom{n}{k} x^k$. In general, if you have some function $f: \\mathbb{N} \\to \\mathbb{R}$, and you want express $f(a)+f(a+1)+…+f(b)$, that is, the sum of $f(k)$ as $k$ ranges from some integer $a$ up to some other integer $b$, you can write it as $\\sum_{k=a}^{b} f(k)$.\n"
"\n"
"**SOCRATES:** Very good.  So we have $(1+x)^n = \\sum_{k=0}^{n} \\binom{n}{k} x^k$. Now, would you allow me to write this as a sum going all the way out to infinity?\n"
"$(1+x)^n = \\sum_{k=0}^{\\infty} \\binom{n}{k} x^k$\n"
"\n"
"**SIMPLICIO:** Hmm. Ok, I think I see what you’re getting at: Pascal’s Triangle has implied zeros everywhere outside, so $\\binom{n}{k}$ is just zero once $k>n$. So you’ve written it as an infinite sum, even though it secretly terminates after finitely many terms. But what purpose does extending it serve?\n"
"\n"
"**SOCRATES:** Well, let me ask you this: can you think of any way of making sense of this formula when $n=-1$?\n"
"\n"
"**SIMPLICIO:** Huh? You can’t use binomial coefficients. How do you choose 3 things from -1 things, that makes no sense!\n"
"\n"
"**SOCRATES:** Ok, sure, but so many great discoveries in mathematics occur when you realize a way to **break the rules**, and follow some pattern **past** its intended... limit (no pun intended…). Put yourself in Newton’s shoes, if you can; what might a genius like him come up with?\n"
"\n"
"**SIMPLICIO:** Well, we do have this other formula for binomial coefficients, not in terms of combinatorics, but just as factorials, $\\binom{n}{k} = \\frac{n!}{k! (n-k)!}$. That still doesn’t help because what the heck is $(-1)!$ supposed to be?! Oh, but wait! We can also write this as:\n"
"\n"
" $\\binom{n}{k} = \\frac{n(n-1)(n-2)\\cdots(n-k+1)}{k!}$\n"
"\n"
"And in this way, we “bypass” the issue of dealing with $(-1)!$, and just go straight to “normal” numbers.\n"
"\n"
"**SOCRATES:** Can you please write this using product notation?\n"
"\n"
"**SIMPLICIO:** Sure, it's just like summation notation but with a $\\Pi$:\n"
"\n"
" $\\binom{n}{k} = \\frac{1}{k!}\\prod_{\\ell=1}^{k}(n-\\ell)$.\n"
"\n"
"**SOCRATES:** Whoops, are you sure about those bounds in the product?\n"
"\n"
"**SIMPLICIO:** Argh! It's so easy to make a silly mistake.\n"
"After writing down the formula, I should have\n"
"checked that I got the right start and end values;\n"
"the counter $\\ell$ should go from $0$ to $k-1$, not from $1$ to $k$.  Is this better?\n"
"\n"
"$\\binom{n}{k} = \\frac{1}{k!}\\prod_{\\ell=0}^{k-1}(n-\\ell)$.\n"
"\n"
"**SOCRATES:** Perfect. Go on.\n"
"\n"
"**SIMPLICIO:** Ok, so if we agree to follow this pattern, then we get:\n"
"\n"
"- $\\binom{-1}{0} = 1$, which makes sense because any row of Pascal's triangle starts with at $1=\\binom{c}{0}$; then\n"
"\n"
"- $\\binom{-1}{1} = (-1)/1! = -1$, which also makes sense because the next term in the \"$c$th row\" of Pascal's triangle is always\n"
"$\\binom{c}{1} = c$; then we get:\n"
"\n"
"- $\\binom{-1}{2} = (-1)(-2)/2! = +1$,\n"
"\n"
"- $\\binom{-1}{3} = (-1)(-2)(-3)/3!=-1$.\n"
"\n"
"Ok so I see the pattern:\n"
"it just alternates between $+1$ and $-1$, so the series goes:\n"
"\n"
" $(1+x)^{-1} = 1 - x + x^2 - x^3+x^4-x^5+\\cdots$.\n"
"\n"
"**SOCRATES:** Very good! But does this formula make any actual\n"
"*sense*? How might you test it?\n"
"\n"
"**SIMPLICIO:** Ok, if that series is supposed to \"represent\"\n"
"$1/(1+x)$, then if I multiply the whole thing by\n"
"$(1+x)$, I should just get $1$. Let's try it:\n"
"\n"
"$(1+x)(1 - x + x^2 - x^3+x^4-x^5+\\cdots) = ?$\n"
"\n"
"I'll first multiply everything by $1$, then by $x$, and add them all up.\n"
"\n"
"$(1 - x + x^2 - x^3+x^4-x^5+\\cdots) + (x - x^2 + x^3- x^4+x^5\\cdots)$\n"
"\n"
"Ok, so if I rearrange terms, then everything cancels out, and only the leading $1$ remains. Great!\n"
"\n"
"**SOCRATES:** Interesting. And are you \"allowed\" to rearrange terms like that?\n"
"\n"
"**SIMPLICIO:** Well.... why not?\n"
"\n"
"**SOCRATES:** Ok, nevermind that for now,\n"
"you seem to be satisfied that it makes sense to say\n"
"that the series\n"
"$1 - x + x^2 - x^3+x^4-x^5+\\cdots$ \"converges\" (again, whatever that means) to $(1+x)^{-1}$.\n"
"\n"
"**SIMPLICIO:** Come to think of it, I knew this already;\n"
"it's just the geometric series! I know that\n"
"\n"
"$1+\\lambda + \\lambda^2+\\lambda^3+\\cdots$\n"
"\n"
"adds up to $1/(1-\\lambda)$, and the series we have just replaces $\\lambda$ with $-x$.\n"
"\n"
"**SOCRATES:** Yes, very good.\n"
"And where might this \"belong\" in Pascal’s triangle?\n"
"\n"
"**SIMPLICIO:**\n"
"Holy cow! Did we just discover an extension of the triangle, going “up”?!\n"
"[![Pascal's Triangle, Extended](images/PascalM1.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"\n"
"**SOCRATES:**\n"
"Indeed, and we can in fact continue this pattern for $n=-2,\n"
"-3, -4,$ and so on. I'll let you work it out yourself, but we actually\n"
"get a *whole other* Pascal's triangle (with some negative signs) *above* the standard one!\n"
"[![Pascal's Triangle, Extended](images/PascalMn.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"See how it still follows the usual rule, that the two numbers above and to the left or right add to the value just below them?\n"
"\n"
"But let's try something even more exotic. Can you make\n"
"the Binomial Theorem work when $n=1/2$?\n"
"\n"
"\n"
"**SIMPLICIO:** Whoa, $n = 1/2$? That's... really pushing it! But let me try using the same formula. So $\\binom{1/2}{k} = \\frac{1}{k!}\\prod_{\\ell=0}^{k-1}(1/2-\\ell)$. Let me work out the first few terms:\n"
"\n"
"- $\\binom{1/2}{0} = 1$ (as always)\n"
"\n"
"- $\\binom{1/2}{1} = (1/2)/1! = 1/2$ (again, matches the pattern we already knew)\n"
"\n"
"- $\\binom{1/2}{2} = (1/2)(-1/2)/2! = -1/8$\n"
"\n"
"- $\\binom{1/2}{3} = (1/2)(-1/2)(-3/2)/3! = 1/16$\n"
"\n"
"- $\\binom{1/2}{4} = \\frac{(1/2)(-1/2)(-3/2)(-5/2)}{4!} =  -\\frac{5}{128}$\n"
"\n"
"So $(1+x)^{1/2} = 1 + \\frac{1}{2}x - \\frac{1}{8}x^2 + \\frac{1}{16}x^3 -\n"
"\\frac{5}{128}x^4+\\cdots$\n"
"\n"
"But wait -- this is supposed to be $\\sqrt{1+x}$?!\n"
"\n"
"**SOCRATES:** Again, go into Newton's thinking: how might he go about justifying whether this formula makes any sense?\n"
"\n"
"**SIMPLICIO:** Oh, ok, I think I see! If we square the formula and multiply everything out, I guess we're supposed to get $1+x$ -- that would justify calling the series $\\sqrt{1+x}$.\n"
"\n"
"**SOCRATES:** Go for it!\n"
"\n"
"**SIMPLICIO:** Ok, so I want\n"
"\n"
"$\\left(1 + \\frac{1}{2}x - \\frac{1}{8}x^2 + \\frac{1}{16}x^3 -\n"
"\\frac{5}{128}x^4+\\cdots\\right)^2$\n"
"\n"
"That means squaring every term, and also adding twice every product of distinct pairs of terms.\n"
"\n"
"**SOCRATES:** Right. Can you think of a good way of keeping track of everything?\n"
"\n"
"**SIMPLICIO:** Oh, I know! Let's group things by the power of $x$ involved. The first one is easy: $x^0=1$, which you only get from squaring the first term. So that coefficient is $1$.\n"
"\n"
"For the coefficient of $x^1$, I can't square anything involving $x$'s, so I\n"
"can only multiply the $x$ term by the constant term, and of course double it.\n"
"That's just $2 \\times 1 \\times \\frac{1}{2}x = x$. So the coefficient of $x$ is $1$.\n"
"\n"
"For $x^2$, I get two contributions  from constant times quadratic: $2 \\times 1 \\times \\left(-\\frac{1}{8}x^2\\right) = -\\frac{1}{4}x^2$ and also from the square of the linear term: $\\left(\\frac{1}{2}x\\right)^2 = \\frac{1}{4}x^2$. So the total coefficient is $-\\frac{1}{4} + \\frac{1}{4} = 0$.\n"
"\n"
"Let's try a few more. To get $x^3$, I need:\n"
"- $2 \\times 1 \\times \\frac{1}{16}x^3 = \\frac{1}{8}x^3$ (constant times the $x^3$ term)\n"
"- $2 \\times \\frac{1}{2}x \\times \\left(-\\frac{1}{8}x^2\\right) = -\\frac{1}{8}x^3$ (the $x$ term times the $x^2$ term)\n"
"\n"
"So the total coefficient of $x^3$ is $\\frac{1}{8} - \\frac{1}{8} = 0$.\n"
"\n"
"This is amazing! It really seems like all the higher-order terms are canceling out perfectly. I bet that will keep happening, and we'll just get the square to come out to exactly $1+x$; the formula really works!\n"
"\n"
"So wait, now we get a whole other row in Pascal's triangle, *between* rows $0$ and $1$?!\n"
"\n"
"[![Pascal's Triangle](images/PascalM12.jpg)](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n"
"\n"
"**SOCRATES:** Beautiful, isn't it!\n"
"\n"
"**SIMPLICIO:** Wait, this is all much simpler than I'm making it. Isn't this just the same thing as the Taylor expansion about $x=0$ of the function $f(x)=\\sqrt{1+x}$?\n"
"I already know how to do this from Calculus.\n"
"\n"
"**SOCRATES:** Yes, very good; but Brook Taylor (of Taylor series) did not prove his general theorem until 1715, a few decades after\n"
"Newton's computation of $\\pi$.\n"
"\n"
"Now, suppose you wanted to compute something like $\\sqrt 3$ -- can you think of a way of doing it using this formula?\n"
"\n"
"**SIMPLICIO:** Hmm the function is $\\sqrt {1+x}$, so I guess I want to set $x=2$. Then I get:\n"
"\n"
"$\\sqrt {1+2} = 1 + \\frac{1}{2}(2) - \\frac{1}{8}(2)^2 + \\frac{1}{16}(2)^3 -\n"
"\\frac{5}{128}(2)^4 + \\cdots$\n"
"\n"
"Adding up these five terms comes out to $11/8 = 1.375$, not so close to $\\sqrt3\\approx1.73$. And the individual terms\n"
"are not so small, for instance, the last one, $\\frac{5}{128}(2)^4 = 5/8 = 0.625$.\n"
"\n"
"**SOCRATES:** Well, sure, if you set $x$ to be large, like $x > 1$, then the powers of $x$ are also larger and larger (and exponentially so!)... Can you think of something else you could do?\n"
"\n"
"**SIMPLICIO:**\n"
"Ah, I think I see! I know that\n"
"$3$ is near $4$, which is a perfect square. So what if we write\n"
"\n"
"$\\sqrt 3 = \\sqrt{4-1} = \\sqrt{4(1-\\frac14)}=2\\sqrt{1-\\frac14}$\n"
"\n"
"So now if I apply our formula with $x=-1/4$ (which is less than one!), I guess I'll get:\n"
"\n"
"$\\sqrt3 \\approx 2\\left(\n"
"1 + \\frac{1}{2}(-1/4) - \\frac{1}{8}(-1/4)^2 + \\frac{1}{16}(-1/4)^3 -\n"
"\\frac{5}{128}(-1/4)^4+\\cdots\n"
"\\right)$\n"
"\n"
"Taking just these five terms, the fraction on the right comes out to $28379/16384\\approx 1.73212$, which is impressively close to $\\sqrt3\\approx1.7320508$.\n"
"We got 3 decimal places of accuracy, nice!\n"
"\n"
"**SOCRATES:** Great! Now you see the power of Newton's Binomial Theorem. Ok, so then let's return all the way back to your original question, about Newton's estimate for $\\pi$.\n"
"\n"
"**SIMPLICIO:** Hmmm, $\\pi$ is the ratio of circumference to diameter in a circle. So where am I supposed to find a length.\n"
"\n"
"**SOCRATES:** Ah, but what did we learn from Archimedes?\n"
"\n"
"**SIMPLICIO:** Oh, that $\\pi$ is also an *area*, not just a length. It's the area of a unit circle $\\pi r^2$ where $r=1$.\n"
"\n"
"**SOCRATES:** Beautiful. And could you find a circle's area lurking somewhere?\n"
"\n"
"**SIMPLICIO:**  I think I see it! Thanks to Descartes, and \"Cartesian\" coordinates, we can express the  circle as the graph of $x^2+y^2=1$, or to make it a function, $y=\\sqrt{1-x^2}$. So we just have to replace $x$ in our series with $-x^2$.\n"
"\n"
"$\n"
"\\sqrt{1-x^2}\n"
"= 1 + \\frac{1}{2}(-x^2) - \\frac{1}{8}(-x^2)^2 + \\frac{1}{16}(-x^2)^3 - \\frac{5}{128}(-x^2)^4+\\cdots\n"
"$\n"
"\n"
"$\n"
"= 1 - \\frac{x^2}{2} - \\frac{x^4}{8} - \\frac{x^6}{16} - \\frac{5x^8}{128} - \\cdots\n"
"$\n"
"\n"
"And the area under the curve $y=\\sqrt{1-x^2}$ from $x=0$ to $x=1$ is\n"
"a quarter circle.\n"
"[![Quarter Circle](images/PiOver4.jpg)](https://en.wikipedia.org/wiki/Area_of_a_circle)\n"
"\n"
"\n"
"**SOCRATES:** Luckily, Newton had just invented calculus! So how else\n"
"could he compute the area under this curve?\n"
"\n"
"**SIMPLICIO:** With an integral! So:\n"
"\n"
"$\\frac{\\pi}4 = \\int_0^1 \\sqrt{1-x^2} \\, dx =\n"
"\\int_0^1 \\left(1 - \\frac{x^2}{2} - \\frac{x^4}{8} - \\frac{x^6}{16} - \\frac{5x^8}{128} - \\cdots\\right) dx$\n"
"\n"
"I'll just integrate term by term,...\n"
"\n"
"**SOCRATES:** Whoa, hang on! Why are you allowed... You know what, nevermind, sorry.\n"
"Just go ahead.\n"
"\n"
"**SIMPLICIO:** Ok, weirdo. Anyway. So integrating term by term, I get:\n"
"\n"
"$\\frac{\\pi}4 = \\left[x - \\frac{x^3}{6} - \\frac{x^5}{40} - \\frac{x^7}{112} - \\frac{5x^9}{1152} - \\cdots\\right]_0^1$\n"
"\n"
"$= 1 - \\frac{1}{6} - \\frac{1}{40} - \\frac{1}{112} - \\frac{5}{1152} - \\cdots $\n"
"\n"
"Wow! So Newton got an infinite series for $\\pi$!\n"
"If I evaluate just these five terms, and cross multiply by the factor of $4$, I get the fraction\n"
"$32057/10080\\approx 3.180$, not bad!\n"
"\n"
"**SOCRATES:** Not bad indeed. You know, Simplicio, many math papers have roughly zero new ideas; they're just\n"
"doing something nobody bothered to do before in a slightly\n"
"newer context. A really good math paper can have one or two genuinely new ideas. Newton is already on new idea number five, and he's still not done!\n"
"\n"
"**SIMPLICIO:** Ok, so what's new idea number six?\n"
"\n"
"**SOCRATES:** Well, remember how you integrated all the way up to $x=1$? In your series,\n"
"\n"
"$\\frac{\\pi}4 = \\left[x - \\frac{x^3}{6} - \\frac{x^5}{40} - \\frac{x^7}{112} - \\frac{5x^9}{1152} - \\cdots\\right]_0^1$\n"
"\n"
"you have all these high powers of $x$ but they're being \"wasted\" because you're setting $x$ to $1$. What if instead  you only integrated up to, say, $x=1/2$?\n"
"\n"
"**SIMPLICIO:** Ooh, cool! Then the series will converge much more rapidly. But wait, that changes the geometry. Instead of a quarter-circle, we now have... a 30 degree sector, which has area $\\pi/12$, plus a 30-60-90 triangle -- ah that must be why you suggested $x=1/2$ -- with area $\\frac12\\times\\frac12\\times\\frac{\\sqrt3}2$.\n"
"\n"
"[![Integrating to x=1/2](images/PiOver12.jpg)](https://en.wikipedia.org/wiki/Area_of_a_circle)\n"
"\n"
"Good thing we already know how to quickly estimate $\\sqrt3$ to high accuracy! (Ah, that's the trade-off: we could set $x$ even smaller, for faster convergence, but then we'll need to deal with ever more complicated geometric evaluations; so $x=1/2$ is a \"sweet spot\".) So now:\n"
"\n"
" $ \\frac{\\pi}{12} +  \\frac{\\sqrt3}8 =\n"
"\\left[x - \\frac{x^3}{6} - \\frac{x^5}{40} - \\frac{x^7}{112} - \\frac{5x^9}{1152} - \\cdots\\right]_0^{1/2}$\n"
"\n"
"$ = \\frac12 - \\frac{1}{6}\\left(\\frac12\\right)^3 - \\frac{1}{40}\\left(\\frac12\\right)^5 - \\frac{1}{112}\\left(\\frac12\\right)^7 - \\frac{5}{1152}\\left(\\frac12\\right)^9 - \\cdots.$\n"
"\n"
"Again evaluating just these five terms already gives the fraction $9874097/20643840$.\n"
"And now isolating $\\pi$ gives the estimate\n"
"\n"
"$\\pi \\approx 12\\times\\left(9874097/20643840 -  \\frac{\\sqrt3}8\\right) \\approx 3.14161,$\n"
"\n"
"which is off by two parts in $100,000$ from the true estimate $\\pi \\approx 3.14159$. All that with just five terms, amazing!\n"
"\n"
"\n"
"**SOCRATES:** Yes, Newton was very impressive indeed.\n"
"Here's a nice YouTube video by Veritasium that discusses this whole saga (right-click to get it to pop up in a new tab):\n"
"[![Veritasium Video](https://img.youtube.com/vi/gMlf1ELvRzc/maxresdefault.jpg)](https://youtu.be/gMlf1ELvRzc)\n"
"\n"
" In fact, a series for $\\pi$ similar to this one was discovered two centuries earlier, by the Indian mathematician Madhava of Sangamagrama.\n"
" And it would take two more centuries until mathematicians figured out how to rigorously justify Newton's work. To do so, they had to figure out:\n"
"\n"
"- What it meant for a sequence of real numbers $a_0, a_1, a_2,\\dots$ to converge?\n"
"- What it meant for a series (that is, sequence of partial sums) $a_0 + a_1 + a_2 +\\cdots$ to converge, and could we sum these numbers in any order we like,\n"
"- What it meant for a series involving a variable, like a power series $a_0 + a_1  x + a_2  x^2+\\cdots$ to converge, and if so, what kind of function it converged to,\n"
"- When can we interchange limits with integrals, like integrating term by term, $\\int(a_0 + a_1  x + a_2  x^2+\\cdots)dx \\overset{?}=\\int \\, a_0\\, dx+\\int \\, a_1  x\\, dx+\\int\\, a_2  x^2\\, dx+\\cdots$,\n"
"\n"
"Etc, etc. We have a lot of work to do!\n"
"\n"
"**SIMPLICIO:** Ok, ok; you've convinced me! On with some actual Real Analysis please."
msgstr ""

#: Game.Levels.L2Pset.L2Pset1
msgid "# Problem 1\n"
"\n"
"We found in Lecture 2 that Newton's Binomial Theorem gave the expansion\n"
"\n"
"$\n"
"\\sqrt{1+x}\\approx\n"
"1\n"
"+\\frac{1}{2}x\n"
"-\\frac{1}{8}x^2\n"
"+\\frac{1}{16}x^3\n"
"-\\frac{5 x^4}{128}+\\cdots\n"
"$\n"
"\n"
"to fourth order.\n"
"Work out the next term in the expansion. This will be a constant `c` with the property that the polynomial\n"
"\n"
"$\\left(1  +\\frac{1}{2}x\n"
"-\\frac{1}{8}x^2\n"
"+\\frac{1}{16}x^3\n"
"-\\frac{5 x^4}{128} + c \\cdot x^5 \\right)^2 - (1 + x)$\n"
"\n"
"only has terms $x ^ 6$ or higher. (We don't *yet* have a way of saying that in Lean, so I have to give you the expansion explicitly.)"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "As usual, compare to what's written in textbooks:\n"
"\n"
"## Natural Language Proof of `1 / n → 0`\n"
"\n"
"**Theorem**: The sequence `a(n) = 1 / n` converges to `0`.\n"
"\n"
"**Proof**:\n"
"Let `ε > 0` be given. We need to find `N : ℕ` such that for all `n ≥ N`, we have `|1 / n - 0| < ε`.\n"
"\n"
"Since `ε > 0`, we have `1 / ε > 0`. By the Archimedean Property, there exists a natural number `N` such that `1 / ε < N`. We choose this value of `N`, and use it.\n"
"\n"
"Now let `n ≥ N` be given. We need to show that `|1 / n| < ε`.\n"
"\n"
"Since `1 / ε < N` and `N ≤ n`, we have that `1 / ε < n`. Since both `1 / ε` and `n` are positive, taking reciprocals reverses the inequality: `1 / n < ε`.\n"
"\n"
"Therefore, `|1 / n - 0| = |1 / n| = 1 / n < ε`, which completes the proof. □\n"
"\n"
"## What We Just Accomplished\n"
"\n"
"This proof demonstrates several key concepts:\n"
"\n"
"1. **The power of the Archimedean Property**: Without it, we couldn't guarantee the existence of a suitable `N`.\n"
"\n"
"2. **The `ε`-`N` definition in action**: We explicitly constructed `N` in terms of `ε`, showing the quantifier structure `∀ε, ∃N, ∀n`.\n"
"\n"
"3. **Rigorous inequality manipulation**: What seems \"obvious\" requires careful attention to positivity and type casting.\n"
"\n"
"4. **The bridge between intuition and formality**: The intuitive idea that \"`1 / n` gets arbitrarily small\" becomes a precise mathematical statement."
msgstr ""

#: Game.Levels.L7Levels.L00_Uniqueness
msgid "If `a : ℕ → ℝ` converges to `L` and `M`, then `L = M`."
msgstr ""

#: Game.Levels.L12Pset.L12Pset2
msgid "# Problem 2:\n"
"\n"
"More fun with Cauchy sequences. True or false: There exists a sequence of real numbers that is Cauchy but not Monotone.\n"
"\n"
"Your solution to this problem **must** begin with either `left` or `right`"
msgstr ""

#: Game.Levels.L9Levels.L04_FiniteSums
msgid "`range N`\n"
"\n"
"For a natural number `N`, `range N` represents the numbers from\n"
"`0` to `N-1` (there are `N` of them).\n"
"\n"
"Usage: `∑ k ∈ range N, k = N * (N + 1) / 2`."
msgstr ""

#: Game.Levels.L6Levels.L01_SplitAnds
msgid "Split Ands"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "We need to find `N`. Use the Archimedean Property: there exists `N` such that `1 / ε < N`. Try: `have f1 : ∃ (N : ℕ), 1 / ε < N := by apply ArchProp hε`"
msgstr ""

#: Game
msgid "*An Introduction to Formal Real Analysis - Interactive Edition*\n"
"\n"
"## About this Course\n"
"\n"
"This course follows the historical crises that forced mathematicians to rebuild\n"
"mathematics from the ground up in the 19th century. You'll learn why concepts\n"
"like `ε`-`δ` definitions became necessary and how to use them to do advanced calculus.\n"
"\n"
"## Credits\n"
"\n"
"* **Course Design:** By Alex Kontorovich alex.kontorovich@rutgers.edu\n"
"* **Interactive Implementation:** Lean 4 Game Engine\n"
"* **Mathematical Content:** Following Rudin, Stein-Shakarchi, Abbot, etc.\n"
"* **Many thanks to:** Jon Eugster, Heather Macbeth, Michael Stoll, and the students of 311H for a lot of technical support, encouragement, and many great suggestions for improvement!"
msgstr ""

#: Game.Levels.L12Levels.L01_MonotoneBdd
msgid "## What You've Accomplished\n"
"\n"
"You've just proven one of the cornerstone theorems of real analysis. By showing that every bounded monotone sequence is Cauchy, you've established a fundamental bridge between order properties (monotonicity and boundedness) and topological properties (convergence).\n"
"\n"
"## The Power of Contradiction\n"
"\n"
"This proof demonstrates the elegance of contradiction in analysis. By assuming the sequence wasn't Cauchy, you were able to extract concrete subsequences that witness persistent gaps. The beauty lies in how these gaps, when iterated, necessarily violate the boundedness assumption - making the contradiction inevitable rather than accidental.\n"
"\n"
"## Why This Theorem Matters\n"
"\n"
"This result is foundational because:\n"
"- It provides a practical convergence test that doesn't require knowing the limit\n"
"- It underlies the Monotone Convergence Theorem in measure theory\n"
"- It establishes that \"order + bounds = convergence\" - a principle that appears throughout analysis\n"
"\n"
"## The Role of Abstraction\n"
"\n"
"By proving this for an abstract type `X` rather than specific number systems, you've seen how mathematical abstraction pays dividends. This single proof now covers both rational and real sequences, and will work for any mathematical structure with the right properties.\n"
"\n"
"## Looking Ahead\n"
"\n"
"In the next level, you'll prove the technical helper lemma `IterateGap` that made this proof possible. You'll see exactly how the orbit construction from Level 1 combines with monotonicity to create the linear accumulation of gaps that drives the contradiction.\n"
"\n"
"The technique you've mastered - using `choose` to extract witnesses, then applying iteration to scale up local properties - is a powerful pattern that appears throughout advanced analysis."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "The use tactic"
msgstr ""

#: Game.Levels.L7Levels.L01_Eventually
#: Game.Levels.L7Levels.L02_SeqOfAbs
msgid "Eventually"
msgstr ""

#: Game.Levels.L10Lecture
msgid "Lecture 10: Algebraic Limit Theorem, Part V"
msgstr ""

#: Game.Levels.L6Levels.L01_SplitAnds
msgid "🎯 Tactical Mastery Achieved! 🎯\n"
"\n"
"Perfect! You've just learned one of the most practical tactics in your Lean toolkit. The `split_ands` tactic might seem simple, but it's incredibly powerful for organizing complex proofs.\n"
"\n"
"## Why This Matters:\n"
"\n"
"Many important mathematical theorems have conclusions that are conjunctions—statements of the form \"A and B and C\". Being able to break these down systematically makes proofs much more manageable and readable.\n"
"\n"
"## Looking Ahead:\n"
"\n"
"As we continue building our arsenal of proof techniques, you'll find that `split_ands` combines beautifully with the convergence arguments we've been developing. Often in analysis, we need to prove that multiple sequences converge, or that a single sequence satisfies multiple properties simultaneously.\n"
"The beauty of mathematical proof lies not just in reaching the destination, but in breaking the journey into clear, logical steps. `split_ands` is your tool for taking that first crucial step: turning one complex goal into several simpler ones."
msgstr ""

#: Game.Levels.L12Levels.L00_SubseqIterate
msgid "For a function `σ : ℕ → ℕ`, if `σ n < σ (n+1)`, then\n"
"for any `i < j`, `σ i < σ j` -- that is, `Subseq σ` holds."
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "Apply the convergence of `a` with tolerance `ε / 2`. Try: `specialize h (ε / 2)`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "The `choose` tactic extracts a witness from an existence statement in a hypothesis."
msgstr ""

#: Game.Levels.L10Levels.L08_Mono
msgid "# Level 3: Subsequence Theorem\n"
"\n"
"A **subsequence** is what you get when you drop out some terms from a sequence and slide everyone left.\n"
"\n"
"**Two Perspectives on Subsequences:**\n"
"\n"
"Most textbooks write $a_{\\sigma(n)}$ and call this \"the subsequence of `a`.\" But we prefer to think of **`σ` itself as the subsequence**—it's the function `σ : ℕ → ℕ` that tells us which terms of `a` to keep. When people use the word \"of\" in mathematics, it implies multiplication, which in the case of functions means composition. So the words \"subsequence of a sequence\" should mean the composition `a ∘ σ` of a sequence `a` with a \"subsequence\" `σ`.\n"
"\n"
"**The Geometric Picture:**\n"
"\n"
"Imagine the graph of `a n`. To form a subsequence:\n"
"1. Drop out some terms (say, keep only positions 0, 2, 5, 7, 11, ...)\n"
"2. Slide everyone left so every index has a value\n"
"3. The new sequence is indexed 0, 1, 2, 3, 4, ...\n"
"\n"
"The function `σ` encodes this relabeling:\n"
"- `σ(0) = 0` (keep term 0)\n"
"- `σ(1) = 2` (skip term 1, keep term 2)\n"
"- `σ(2) = 5` (skip terms 3,4, keep term 5)\n"
"- etc.\n"
"\n"
"**Definition: `Subseq σ`**\n"
"\n"
"A function `σ : ℕ → ℕ` is a subsequence if it's **strictly monotone increasing**:\n"
"```\n"
"∀ i j, i < j → σ(i) < σ(j)\n"
"```\n"
"\n"
"This ensures we preserve the original ordering—we can't rearrange terms, only delete some!\n"
"\n"
"**Key Lemma: `SubseqGe`**\n"
"\n"
"If `σ` is a subsequence, then `n ≤ σ(n)` for all `n`.\n"
"\n"
"Intuition: as you drop terms and relabel, indices can only \"spread out,\" never compress. The new index `n` corresponds to some original index `σ(n) ≥ n`. (You already proved this in Problem Set 8, Exercise 4.)\n"
"\n"
"**The Theorem:** If `a n → L` and `σ` is a subsequence, then `(a ∘ σ) n → L`.\n"
"\n"
"Translation: **every subsequence of a convergent sequence converges to the same limit**.\n"
"\n"
"**Proof Strategy:**\n"
"\n"
"This one is surprisingly simple! Given `ε > 0`:\n"
"- Use convergence of `a` to find `N` such that `|a m - L| < ε` for all `m ≥ N`\n"
"- For any `n ≥ N`, note that `σ(n) ≥ n ≥ N` (by `SubseqGe`)\n"
"- Therefore `|a(σ(n)) - L| < ε`\n"
"\n"
"Done! The same `N` works for both the sequence and all its subsequences.\n"
"\n"
"**Powerful Consequence:**\n"
"\n"
"If a sequence has two subsequences converging to **different limits**, then the sequence itself **does not converge**! This gives us a new way to prove divergence. (See Lecture 10 Exercises.)"
msgstr ""

#: Game.Levels.L11Levels.L03_IsBddOfCauchy
msgid "Level 3 : Cauchy Implies Bounded"
msgstr ""

#: Game.Levels.L6Pset.L6Pset4
msgid "# Problem 4\n"
"\n"
"You are given that a sequence `a : ℕ → ℝ` with the property that it takes arbitrarily large values exceeding 10 in absolute value.\n"
"Prove that cannot have a limit less than 5."
msgstr ""

#: Game.Levels.L12Levels.L01_MonotoneBdd
msgid "The `push_neg` tactic pushes negations through universal and existential quantifiers, inequalities, etc."
msgstr ""

#: Game.Levels.L12Levels.L02_IterateGap
msgid "# Level 4: Iterated Gaps\n"
"\n"
"Now it's time to prove the technical helper lemma that made Level 2 possible. This result captures the precise mechanism by which persistent gaps in a monotone sequence accumulate under iteration.\n"
"\n"
"## The Setup\n"
"\n"
"Recall from Level 2: we had a bounded monotone sequence that we assumed (for contradiction) was not Cauchy. This gave us:\n"
"- Some `ε > 0` representing the persistent gap size\n"
"- Subsequences `τ` and `σ` where `τ n ≥ n` and `σ n ≥ τ n`\n"
"- The gap condition: `ε ≤ |a (σ n) - a (τ n)|` for all `n`\n"
"\n"
"The question was: how do these gaps accumulate when we iterate `σ`?\n"
"\n"
"## The Goal\n"
"\n"
"**Your task:** Prove that `∀ k, k * ε ≤ a (σ^[k] 0) - a 0`\n"
"\n"
"In words: iterating `σ` exactly `k` times from `0` gives us at least `k * ε` total growth from the starting value. This linear accumulation is what drives the contradiction with boundedness.\n"
"\n"
"## Why This is Non-Trivial\n"
"\n"
"You might think: \"If we get `ε` growth each step, then after `k` steps we get `k * ε` growth - isn't that obvious?\" But there are subtle issues:\n"
"- We don't get `ε` growth from `σ^[i] 0` to `σ^[i+1] 0` directly\n"
"- Instead, we get `ε` growth from `τ(σ^[i] 0)` to `σ(σ^[i] 0)`\n"
"- We need to carefully account for the \"gaps\" between these points\n"
"\n"
"The proof requires showing that monotonicity allows us to \"telescope\" these gaps correctly.\n"
"\n"
"## The Strategy\n"
"\n"
"**Induction on k:**\n"
"- **Base case:** `k = 0` gives `0 ≤ a 0 - a 0`, which is trivial\n"
"- **Inductive step:** Assume we have `k * ε ≤ a (σ^[k] 0) - a 0`. We need to show `(k+1) * ε ≤ a (σ^[k+1] 0) - a 0`\n"
"\n"
"The key insight: apply the gap condition at the point `σ^[k] 0` to get:\n"
"`ε ≤ |a (σ (σ^[k] 0)) - a (τ (σ^[k] 0))|`\n"
"\n"
"Then use monotonicity and the `succ_iterate` theorem to connect this to the growth from `σ^[k] 0` to `σ^[k+1] 0`."
msgstr ""

#: Game.Levels.L12Levels.L00_SubseqIterate
msgid "Try starting your proof with `apply subseq_of_succ`."
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
#: Game.Levels.L8Pset.L8Pset1
msgid "# Problem 1"
msgstr ""

#: Game.Levels.L14Levels.L01_BolzanoWeierstrass
msgid "Bolzano-Weierstass"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "If `a n = 1 / n`, then `SeqLim a 0`; that is, the sequence\n"
"`1 / n` converges to zero."
msgstr ""

#: Game.Levels.L10Levels.L06_Prod
msgid "# Level 1: Big Boss - Product of Sequences\n"
"\n"
"This is the capstone of the Algebraic Limit Theorem! We've already proven that limits behave well under addition, scalar multiplication, and inversion. Now we tackle multiplication of sequences.\n"
"\n"
"**The Challenge:** If `a n → L` and `b n → M`, prove that `a n * b n → L * M`.\n"
"\n"
"**The Key Insight:** We need to write the error `a n * b n - L * M` in a way that separates the contributions from each sequence. The trick is to add and subtract `b n * L`:\n"
"\n"
"```\n"
"a n * b n - L * M = (a n - L) * b n + L * (b n - M)\n"
"```\n"
"\n"
"**Why does this work?** Think about rectangles! The product `a n * b n` is the area of a rectangle with dimensions `a n` by `b n`, while `L * M` is the limiting rectangle. The difference decomposes into two strips:\n"
"- `(a n - L) * b n`: a thin vertical strip (small width, bounded height)\n"
"- `L * (b n - M)`: a thin horizontal strip (bounded width, small height)\n"
"\n"
"The corner piece `(a n - L) * (b n - M)` gets absorbed into the first term—it's doubly small so it doesn't hurt us!\n"
"\n"
"**The Strategy:**\n"
"1. Use `BddOfConvNonzero` to get a bound `K` on the sequence `b`\n"
"2. Make `|a n - L| < ε/(2*K)` to control the first term\n"
"3. Make `|b n - M| < ε/(2*|L|)` to control the second term\n"
"4. Combine using the triangle inequality\n"
"\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L13Levels.L03_MonotoneSubseq
msgid "# Level 1 **Big Boss:**  Monotone Subsequence\n"
"\n"
"## New definitions:\n"
"\n"
"- `IsAPeak`: Standing at `a n`, you can look down at all future values.\n"
"\n"
"`def IsAPeak {X : Type*} [LinearOrder X] (a : ℕ → X) (n : ℕ) : Prop := ∀ m > n, a m ≤ a n`\n"
"\n"
"- A sequence `a : ℕ → X` (where `X` could be `ℚ` or `ℝ`) satisfies `UnBddPeaks` if there are arbitrarily large peaks.\n"
"\n"
"`def UnBddPeaks {X : Type*} [LinearOrder X] (a : ℕ → X) : Prop := ∀ k, ∃ n > k, IsAPeak a n`\n"
"\n"
"## The Goal\n"
"\n"
"Assume your sequence `a : ℕ → X` does **not** have `UnBddPeaks`. Prove that it then has a `Monotone` subsequence. (In the homework, you will show the opposite: if the sequence *does* have `UnBddPeaks`, then it has an `Antitone` -- that is, non-increasing -- subsequence.)\n"
"\n"
"## New definition:\n"
"\n"
"- `if` `then` `else`\n"
"\n"
"## New theorems:\n"
"\n"
"- `lt_of_not_ge`\n"
"\n"
"It says: If `¬ (m ≤ n)`, then `n < m`."
msgstr ""

#: Game.Levels.L7Levels.L03_SeqInvLim
msgid "For any real numbers `x` and `y`, we have `|x / y| = |x| / |y|`."
msgstr ""

#: Game.Levels.L1Pset.L1Pset5
msgid "# Problem 5\n"
"\n"
"You've learned about adding hypotheses with `have`, and that you can call tactics not\n"
"just to act on the Goal, but  also on hypotheses, via adding `at HypothesisName` at the end.\n"
"You also know that calling the `rewrite` tactic with a hypothesis `h : X = Y` takes the *left hand side* `X` and replaces it by `Y`. But what if you needed instead to replace `Y`'s by `X`'s? We call that \"backwards rewriting\". The syntax for that is:\n"
"\n"
"`rewrite [← h]`\n"
"\n"
"or\n"
"\n"
"`rewrite [← h] at h2`\n"
"\n"
"to do it at some other hypothesis, `h2`. You get the backwards arrow by typing \\left,\n"
"that is, the backslash, then the word `left`, and then a space.\n"
"\n"
"You may (or may not) find that useful in this problem."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "For any sequence `a : ℕ → ℝ` and constant `L : ℝ`, and\n"
"hypothesis `h : ∀ n, a n = L`, the theorem `ConstLim`\n"
"proves that `SeqLim a L`, that is, the (constant) sequence `a` converges to `L`."
msgstr ""

#: Game.Levels.L6Levels.L04_Cases'
msgid "# 🔄 Case Analysis Mastered! 🔄\n"
"\n"
"Excellent! You've just learned one of the most powerful proof techniques in mathematics: case analysis. The `cases'` tactic embodies a fundamental principle of logical reasoning—when you don't know which of several possibilities is true, you prove your result holds in every case.\n"
"\n"
"**Why This Matters:**\n"
"Case analysis is everywhere in mathematics. From proving that every integer is either even or odd, to showing that continuous functions on closed intervals achieve their extrema, the ability to systematically consider all possibilities is crucial for rigorous reasoning.\n"
"\n"
"**The Beauty of Completeness:**\n"
"Notice how `cases'` forced you to handle both scenarios completely. This isn't just a formal requirement—it ensures that your proof is truly bulletproof. No matter which case actually occurs, your argument will hold.\n"
"\n"
"**Strategic Insight:**\n"
"In our example, both cases led to the same algebraic manipulation (`ring_nf`), but that won't always be true. Often, different cases require entirely different approaches. Learning to adapt your strategy to each case while keeping sight of the overall goal is a key mathematical skill.\n"
"\n"
"**Looking Forward:**\n"
"As we continue with convergence proofs and other analysis topics, you'll find `cases'` invaluable for handling statements like \"either the sequence is bounded above or below\" or \"either the limit exists or the sequence diverges.\" The systematic approach you've learned here will serve you well in these more complex scenarios.\n"
"\n"
"Mathematics is about leaving no stone unturned, no possibility unconsidered. With `cases'`, you now have the tools to be completely thorough in your logical investigations."
msgstr ""

#: Game.Levels.L2PsetIntro
msgid "Pset 2"
msgstr ""

#: Game.Levels.L12Pset.L12Pset1
msgid "# Problem 1:\n"
"\n"
"In lecture, we proved `IsCauchyOfMonotoneBdd`: if a sequence is `Monotone` and bounded (from above),\n"
"then it `IsCauchy`. Here you'll prove the same thing but going down: if a sequence is `Antitone` (that\n"
"is, non-increasing -- so decreasing but not necessarily strictly so; `i ≤ j → a j ≤ a i) and bounded\n"
"from *below*, then it's Cauchy.\n"
"\n"
"Theorem: `IsCauchyOfAntitoneBdd`.\n"
"\n"
"## New definition: `Antitone`\n"
"\n"
"Hint: You don't need to reprove everything from scratch! I'll give you two tools:\n"
"\n"
"## New theorems:\n"
"\n"
"- `MonotoneNeg_of_Antitone`: if `a` is `Antitone`, then `-a` is `Monotone`.\n"
"\n"
"- `IsCauchyNeg`: if `IsCauchy a`, then so is `IsCauchy (-a)`."
msgstr ""

#: Game.Levels.L10Levels.L07_Order
msgid "Order Limit Theorem"
msgstr ""

#: Game.Levels.L1RealAnalysisStory
msgid "# A First Course in Real Analysis\n"
"\n"
"You may want to pull the left-most slider all the way to the right; what follows is a discussion\n"
"between \"Socrates\" and \"Simplicio,\" which hopefully  explains what it is we're trying to do here.\n"
"\n"
"**SIMPLICIO:** What is \"Real Analysis\"?\n"
"\n"
"**SOCRATES:** Oh, it's just Calculus, but done \"right\".\n"
"\n"
"**SIMPLICIO:** Huh? Why does Calculus need a new name? What's wrong with it?\n"
"\n"
"**SOCRATES:** Well, nothing really. Quick: what's a derivative?\n"
"\n"
"**SIMPLICIO:** Easy! If I have a function $f : \\R \\to \\R$ and it's differentiable at $x$, then the\n"
"derivative is $f'(x) := \\lim_{h \\to 0}\\frac{f(x+h) - f(x)}{h}$. This represents the \"instantaneous\" slope\n"
"of the graph of the function $y=f(x)$ at the point $(x, f(x))$.\n"
"[![derivative](images/Deriv.jpg)](https://en.wikipedia.org/wiki/Derivative)\n"
"\n"
"**SOCRATES:** Very good! And tell me please, what is an integral?\n"
"\n"
"**SIMPLICIO:** That's easy, too! If you want to integrate our function $f$ along an\n"
"interval, $[a, b]$, say, you pretend that you have infinitely many, infinitely small rectangles, work out their\n"
"areas as base times height, and add them up:\n"
"$\\int_a^b f(x)dx := \\lim_{N\\to\\infty} \\sum_{j=1}^N \\frac{b-a}{N} f\\left(a + j\\frac{b-a}{N}\\right)$\n"
"[![integral](images/Integral.jpg)](https://en.wikipedia.org/wiki/Integral)\n"
"\n"
"**SOCRATES:** Great. And what are the two Fundamental Theorems of Calculus?\n"
"\n"
"**SIMPLICIO:** These too are easy! The first one says that if you make a new function by integrating $f$\n"
"up to a variable amount, $x$, that is, let\n"
" $F(x) := \\int_a^x f(t)dt$, then the derivative of the new function is just $F'(x) = f(x)$.\n"
"\n"
"**SOCRATES:** And the second?\n"
"\n"
"**SIMPLICIO:**\n"
"The second one says that, conversely, if $F$ is an antiderivative of $f$, that is, $F'(x)=f(x)$, then\n"
"it's easy to work out the area under the curve, because\n"
" $\\int_a^b f(x)dx = F(b) - F(a)$.\n"
"So differentiation and integration are inverse operations!\n"
"\n"
"**SOCRATES:** Perfect. Now, here's the problem. You used words like \"limit\", \"infinitely many\", \"infinitely small\", and so on. What do they *actually* mean?\n"
"\n"
"**SIMPLICIO:** Oh, you know, it's when something  happens \"eventually\". You just have to get used to\n"
"the feel of it.\n"
"\n"
"**SOCRATES:** Hmm yes, I see. I agree that that's an OK way to think of it, for a while at least, and one that suited Newton (who\n"
"was quite uncomfortable with such words), and Leibniz (who was more care-free here), the two 17th century inventors of\n"
"calculus (if you don't count people like the ancient Greeks Eudoxus and Archimedes, or the 14th century Indian Madhava... but this isn't a history lesson). Leibniz taught the Bernoulli\n"
"brothers (the world's \"first AP Calc students\"!), who taught, among others, the Marquis de l'Hopital, and the great Leonhard Euler (the first \"Calc native\"), who taught the rest of us. All was going quite well... and then came the 19th Century.\n"
"[![NewtonLeibnizEudoxusArchimedesMadhavaBernoulliEuler](images/People.jpg)](https://en.wikipedia.org/wiki/History_of_calculus)\n"
"\n"
"**SIMPLICIO:** Huh? What happened in the 19th Century?\n"
"\n"
"**SOCRATES:** Well you see, a guy named Augustin-Louis Cauchy came along (roughly in the 1810s), and started making a fuss that we weren't really doing things perfectly \"rigorously\".\n"
"He set out to reprove the theorems of calculus using precise definitions rather than hand-waving.\n"
"He was making great progress, including proving statements like: the limit of continuous functions is continuous.\n"
"[![Cauchy](images/Cauchy.jpg)](https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy)\n"
"\n"
"**SIMPLICIO:** Sure, that sounds perfectly reasonable. A limit is a continuous process, so you do that to\n"
"continuous functions, and of course in the end you should get something continuous, too.  No?\n"
"\n"
"\n"
"**SOCRATES:** Well, the problem is that around the same time, a guy named Joseph Fourier was going around claiming\n"
" that he could add up a bunch of sines and cosines, and get basically any function he wants, including, say, the discontinuous sawtooth!\n"
"\n"
"**SIMPLICIO:** What?!\n"
"\n"
"**SOCRATES:** Look for yourself: Here's a graph of $\\sum_{n=1}^{100}\\frac1n \\sin(nx)$. As you take 100\n"
"out to infinity, Fourier claims that this will get\n"
"closer and closer to a sawtooth function!\n"
"[![Fourier](images/Fourier.jpg)](https://en.wikipedia.org/wiki/Joseph_Fourier)\n"
"\n"
"**SIMPLICIO:** Whoa. Wait, I can think of an even easier example: just look at the simplest family of\n"
"polynomials, $f_n(x) = x^n$, on the unit interval $[0,1]$. When you take high powers of any point\n"
"strictly less than $1$, that goes to $0$ in the limit, but powers of $1$ itself always stay at $1$.\n"
"So the limiting function is discontinuous, too! What the heck is going on here?\n"
"![Power Functions](images/Powers.png)\n"
"\n"
"\n"
"**SOCRATES:** Very good, Simplicio! Exactly right, between Fourier and Cauchy, they \"broke math\".\n"
" You break it, you buy it!\n"
"\n"
"**SIMPLICIO:** Ok, so what's the right answer, how *do* you do calculus rigorously?\n"
"\n"
"**SOCRATES:** Not so fast! Things got even worse, and by the mid-19th century, people realized that\n"
"we don't even know what the real numbers *are*!\n"
"\n"
"**SIMPLICIO:** What? What do you mean, what are they? Here they are right here: There's zero, and one, and $-2$, and $\\frac35$, and\n"
"$\\sqrt 2$, and $e$ and $\\pi$. What's the problem?\n"
"[![RealNumbers](images/RealLine.png)](https://en.wikipedia.org/wiki/Real_number)\n"
"\n"
"**SOCRATES:** Well, do you remember that you need something called the Intermediate Value Theorem\n"
"in calculus?\n"
"\n"
"**SIMPLICIO:** Sure, if you have a continuous function, and it goes from being negative to being positive,\n"
"then it has to cross zero at some point in between.\n"
"\n"
"**SOCRATES:** Very good. Tell me about the function $f : x \\mapsto x^2 - 2$. (We say: \"$f$ maps\n"
"$x$ to $x^2-2$\". Note that we write $f : \\R \\to \\R$ to mean that $f$ takes real numbers to real numbers, but\n"
"replace $\\to$ with $\\mapsto$ (see the tail on the second arrow?) when we want to say what happens to a particular input $x$ under the action of\n"
"$f$. Let me remind you that $x$ here is a dummy variable, so it's the same function if we'd said $f : u \\mapsto u ^ 2 - 2$.) In particular, what happens to $f$ on the rational numbers?\n"
"\n"
"**SIMPLICIO:** Ok, well if $x$ is a rational number, then so is $x^2$, and hence so is $x^2-2$.\n"
"So actually, we could say that $f : \\mathbb Q \\to \\mathbb Q$, that is, $f$ maps rational numbers to rational numbers.\n"
"Over the reals, the graph of $y=f(x)$ is a simple parabola.\n"
"But you'd asked me about the Intermediate Value Theorem. Hmm. When $x=0$, I know that $f(x)$ will\n"
"be $f(0)=0^2-2=-2$ which is negative. And when $x=2$, $f(2)=2^2-2=2$ which is positive.\n"
"\n"
"**SOCRATES:** Go on...\n"
"\n"
"**SIMPLICIO:** So there's a root of $f$ somewhere between $0$ and $2$. But the place where $f$ crosses the $x$-axis is at $x=\\sqrt2\\approx 1.41\\dots$.\n"
"\n"
"**SOCRATES:** And what did the Pythagoreans know about this number?\n"
"\n"
"**SIMPLICIO:** Supposedly one of them, Hippasus, figured out that $\\sqrt2$ is irrational, which ruined\n"
"their entire theory of geometry and form (they originally believed that *all* numbers were rational); legend has it\n"
"that Hippasus was drowned at sea for his herecy.\n"
"\n"
"**SOCRATES:** So...\n"
"\n"
"**SIMPLICIO:** So wait, if we just restrict to rational inputs, then this parabola is negative, and then\n"
"it's positive, and it *never* crosses zero?! But there's tons of rational numbers almost everywhere you look. So what makes the real numbers different from the\n"
"rational numbers, so that the Intermediate Value Theorem actually holds?\n"
"\n"
"**SOCRATES:** Ah! Now, my friend, we are ready to begin."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Also clear denominators in our key inequality: `field_simp at eps_inv_lt_N`"
msgstr ""

#: Game.Levels.L7Levels.L04_ByCases
msgid "The `by_cases` tactic has syntax `by_cases h : fact`, where `h` is your name for a new hypothesis,\n"
"and `fact` is the fact claimed in the hypothesis. Calling `by_cases` creates two subgoals, one with\n"
"the additional hypothesis `h : fact`, and the second has the hypothesis `h : ¬ fact`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "# When things are identical to themselves\n"
"\n"
"Sometimes in mathematics, we need to prove that something equals itself. For example, we might need to prove that $x ^ 2 + 2 * y = x ^ 2 + 2 * y$.\n"
"\n"
"This isn't quite the same as our previous exercise. There, we had a hypothesis `h` that told us `x = 5`, and we used `apply h` to prove the goal `x = 5`.\n"
"\n"
"But now we don't have any hypothesis that says `x ^ 2 + 2 * y = x ^ 2 + 2 * y`. We're just being asked to prove that some expression equals itself. We can't say `apply something` because there's no `something`.\n"
"\n"
"Instead, we will use what mathematicians call the *reflexive property* of equality: everything is equal to itself. In Lean, if you get to a situation where you're trying to prove an equality, and the two things on both sides are *identical*, then the syntax is to give the command `rfl` (short for \"reflexivity\").\n"
"\n"
"Try it out!"
msgstr ""

#: Game.Levels.L7Levels.L02_SeqOfAbs
msgid "## What You've Proven\n"
"\n"
"Great work! You've proven that the absolute value function **preserves convergence**: if\n"
"`a n → L`, then `|a n| → |L|`. This is one of the cleanest and most elegant proofs in\n"
"the course so far.\n"
"\n"
"## The Power of Lipschitz Continuity\n"
"\n"
"The key insight was that because absolute value is Lipschitz continuous with constant 1,\n"
"we have `||a n| - |L|| ≤ |a n - L|`. This single inequality immediately gives us the\n"
"convergence we need—no complicated epsilon manipulations, no splitting cases, just a\n"
"direct application of the Lipschitz property.\n"
"\n"
"## The Bigger Picture\n"
"\n"
"This theorem is your first glimpse of a profound principle in analysis: **continuous\n"
"functions preserve limits**. We've just proven this for one specific continuous function\n"
"(absolute value), but the same idea works for all continuous functions. If `f` is\n"
"continuous and `a n → L`, then `f(a n) → f(L)`. This is why calculus works the way it\n"
"does—you can \"pass limits through\" continuous functions like polynomials, exponentials,\n"
"trigonometric functions, and more.\n"
"\n"
"The Lipschitz property is even stronger than continuity—it gives us quantitative control\n"
"over how fast the function can change. This makes Lipschitz functions particularly\n"
"well-behaved and useful throughout analysis, differential equations, and optimization."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Therefore `n > 0`; try: `have npos : (0 : ℝ) < n := by linarith [Npos, N_le_n]`"
msgstr ""

#: Game.Levels.L11PsetIntro
msgid "Pset 11"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "The Convergence of a Sequence"
msgstr ""

#: Game.Levels.L12Levels.L01_Choose
msgid "You can make `σ` by taking an orbit of `τ`! You can start at any base point, as long as `p` is satisfied for that base point; since we don't *a priori* know of such a point, we can start with `τ 0`. Try writing `let σ : ℕ → ℕ := fun n ↦ τ^[n] (τ 0)`."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Cast the inequality `n ≥ N` to reals, so that `linarith` can see and access it: `have N_le_n : (N : ℝ) ≤ n := by exact_mod_cast n_ge_N`"
msgstr ""

#: Game.Levels.L10Levels.L06_Prod
msgid "Big Boss : Product of Sequences"
msgstr ""

#: Game.Levels.L3Pset.L3Pset4
msgid "Determine the limit `L` of the sequence `a (n) = (3n + 8) / (2n + 5)`, and prove that `a` indeed converges to `L`."
msgstr ""

#: Game.Levels.L6Pset.L6Pset1
#: Game.Levels.L6Pset.L6Pset2
#: Game.Levels.L6Pset.L6Pset3
#: Game.Levels.L6Pset.L6Pset4
#: Game.Levels.L6Pset.L6Pset5
#: Game.Levels.L7Pset.L7Pset1
#: Game.Levels.L7Pset.L7Pset2
#: Game.Levels.L7Pset.L7Pset3
#: Game.Levels.L8Pset.L8Pset1
#: Game.Levels.L8Pset.L8Pset2
#: Game.Levels.L8Pset.L8Pset3
#: Game.Levels.L8Pset.L8Pset4
#: Game.Levels.L9Pset.L9Pset1
#: Game.Levels.L9Pset.L9Pset2
#: Game.Levels.L9Pset.L9Pset3
msgid "Prove the statement."
msgstr ""

#: Game.Levels.L7Levels.L04_ByCases
msgid "If `a : ℕ → ℝ` converges to `L` (with *no* assumption that `L ≠ 0`), then there is an `N` so that\n"
"for all `n ≥ N`, `|a (n)| ≥ |L| / 2`."
msgstr ""

#: Game.Levels.L6Levels.L01_SplitAnds
msgid "The `split_ands` tactic breaks apart \\\"and\\\" Goals into individual pieces. If your goal is `h₁ ∧ h₂ ∧ h₃`, then calling `split_ands` will break that into three separate goals, the first being\n"
"`h₁`, the second `h₂`, and of course `h₃`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "Every mathematical expression equals itself."
msgstr ""

#: Game.Levels.L10Levels.L06_Prod
msgid "If sequences `a b : ℕ → ℝ` converge with `a` going to `L ≠ 0` and `b` going to `M ≠ 0`, then `a n * b n` converges to `L * M`."
msgstr ""

#: Game.Levels.L7Levels.L00_Uniqueness
msgid "To give a proof by contradiction, the syntax is : `by_contra h`, which adds a hypothesis with the name `h` (or whatever you want), which is the negation of the current Goal, and changes the goal to `false`."
msgstr ""

#: Game.Levels.L9PsetIntro
msgid "# Problem Set 9\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "# Rewriting with equalities\n"
"\n"
"Now let's learn about rewriting. Suppose you have a hypothesis called `Bob : x = 2`, and your goal is to prove that `x + y = 2 + y`.\n"
"\n"
"Can you use `rfl`? No, because the two sides of the goal (`x + y` and `2 + y`) are not *identically* the same.\n"
"\n"
"Can you use `apply Bob`? No, because `Bob` says `x = 2`, which is not what the goal is asking for.\n"
"\n"
"But you can use the hypothesis `Bob` to *rewrite* the goal. Since `Bob` tells us that `x = 2`, we can replace `x` with `2` in our goal.\n"
"\n"
"In Lean, if you have a hypothesis which is an equality, and you want to replace the *left hand side* of that equality with the *right hand side* in your goal, you use the `rewrite` tactic. The syntax is:\n"
"\n"
"`rewrite [hypothesis_name]`\n"
"\n"
"Unfortunately, those square brackets are part of the Lean syntax, and there's nothing you or I can do about them right now. Just remember: `rewrite [Bob]` means \"use the equality in `Bob` to rewrite the goal.\"\n"
"\n"
"After you rewrite, you're not done. But you should know how to finish from there.\n"
"\n"
"Try it out!"
msgstr ""

#: Game.Levels.L6Levels.L02_LeftRight
msgid "Left and Right"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "# Proving existence\n"
"\n"
"Sometimes in mathematics, you need to prove that something exists. For example, suppose I wanted to ask you what the binomial coefficient in front of $x^2y^2$ is\n"
"in the expansion of $(x+y)^4$; how would I do it? Lean can't ask questions,\n"
"it can only prove theorems! So the way I would ask this is:\n"
"  prove that there exists a real number $c$ such that\n"
"\n"
"  $(x+y)^4 = x^4 + 4x^3y + cx^2y^2 + 4xy^3 + y^4$.\n"
"\n"
"  The way to prove that such a number\n"
"  exists is to exhibit it, that is, tell me which number to *use*,\n"
"  and then prove that that number indeed satisfies the equation.\n"
"\n"
"This is called an *existential statement*. In Lean, as in mathematics,\n"
"existence is written using `∃` (read: \"there exists\").\n"
"This symbol is called the *existential quantifier*, and is written in Lean by typing \\exists, that is, a backslash, then the word `exists`, and then a space.\n"
"So this goal would look in Lean like so:\n"
"\n"
"`∃ (c : ℝ), (x + y)^4 = x^4 + 4*x^3*y + c*x^2*y^2 + 4*x*y^3 + y^4`\n"
"\n"
"To prove an existence statement, you need to provide a specific value that works. This is where the `use` tactic comes in.\n"
"\n"
"If you think you know what value of `c` would work, you can write `use 42` (or with `42` replaced by whatever number you think is right). Lean will then substitute that value and ask you to prove that the resulting equation is true.\n"
"\n"
"Try writing `use`, then a space, and then a number. Do you see what to do after that?"
msgstr ""

#: Game.Levels.L12Pset.L12Pset1
msgid "Prove `IsCauchyOfAntitoneBdd`"
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "The `have` tactic has the following\n"
"syntax: `have NewHypothesisName (Assumptions) : Claim := by GiveTheProof`.\n"
"This creates a new hypothesis called\n"
"`NewHypothesisName : ∀ (Assumptions), ClaimHolds`."
msgstr ""

#: Game.Levels.L9Levels.L04_FiniteSums
msgid "If `a : ℕ → X` (where `X` could be `ℚ` or `ℝ`) is a sequence, then any term `|a n|`\n"
"for `n < N` is less than the sum of all the terms for `n = 0` to `N - 1`."
msgstr ""

#: Game.Levels.L14Lecture
msgid "Lecture 14: Bolzano-Weierstrass"
msgstr ""

#: Game.Levels.L6Levels.L02_LeftRight
msgid "When your goal is to prove an \\\"Or\\\" statement, `P ∨ Q`, you can do that by proving either `P` or `Q`. If you want to prove `Q`, then say `right`, and the Goal will turn into `Q`."
msgstr ""

#: Game.Levels.L14Levels.L01_BolzanoWeierstrass
msgid "`|x| ≤ y ↔ -y ≤ x ≤ y`"
msgstr ""

#: Game.Levels.L2Pset.L2Pset2
msgid "# Problem 2\n"
"\n"
"Do the same for the exponent $3/2$. Find constants `c`, `d`, and `e` so that:\n"
"\n"
"$(1 + \\frac32 x + c \\cdot x^2 + d \\cdot x^3 + e \\cdot x^4)^2 - (1 + x) ^ 3$\n"
"\n"
"has only terms of degree five or higher.\n"
"\n"
"Hint: when you have multiple existential quantifiers, you can just write a single `use`\n"
"and separate the answers by a comma, like so: `use 6, 7, 42` (in place of: `use 6`, then `use 7`, then `use 42`)."
msgstr ""

#: Game.Levels.L13PsetIntro
msgid "Pset 13"
msgstr ""

#: Game.Levels.L12Levels.L01_MonotoneBdd
msgid "If `a n ≤ a (n+1)` holds for all `n`, then `a` is `Monotone`."
msgstr ""

#: Game.Levels.L11Levels.L01_IsCauchyOfLim
msgid "`(a : ℕ → X) : Prop := ∀ (ε : X), 0 < ε → ∃ N : ℕ, ∀ n ≥ N, ∀ m ≥ n, |a m - a n| < ε`\n"
"\n"
"For a sequence `a : ℕ → X` (where `X` could be `ℚ` or `ℝ`) is said to satisfy `IsCauchy` (that is, the sequence \\\"is Cauchy\\\") if: for every `ε > 0`, there exists `N : ℕ` such that for all `n ≥ N` and `m ≥ n`, we have `|a m - a n| < ε`."
msgstr ""

#: Game.Levels.L6Levels.L01_SplitAnds
msgid "# Level 2: Split Ands - Breaking Down Complex Goals\n"
"\n"
"Now that you've conquered the Big Boss and proven that sums of convergent sequences converge, you've experienced firsthand how mathematical proofs often require us to establish multiple related facts simultaneously. In our previous proof, we needed to show that both individual sequences satisfied their epsilon conditions, and then combine these results.\n"
"\n"
"This pattern -- needing to prove several statements at once -- appears constantly in mathematics. Fortunately, Lean provides us with powerful tools to handle such situations elegantly. When your goal involves proving multiple statements connected by \"and\" (`∧`), the `split_ands` tactic becomes your best friend.\n"
"\n"
"Think of `split_ands` as a way to break down a complex manufacturing specification into individual quality checks. Instead of trying to verify that a product meets three different standards all at once, we can tackle each standard separately and systematically.\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"- `split_ands`\n"
"\n"
"The `split_ands` tactic breaks apart \"and\" Goals into individual pieces. If your goal is `h₁ ∧ h₂ ∧ h₃`, then calling `split_ands` will break that into three separate goals, the first being\n"
"`h₁`, the second `h₂`, and of course `h₃`"
msgstr ""

#: Game.Levels.L7Lecture
msgid "Lecture 7: Algebraic Limit Theorem, Part III"
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "Did you end up using `huv`?\n"
"And then `specialize`ing it with `u` and `v` replaced, respectively, by `x` and `y`?\n"
"Or did you think of going via the more direct route:\n"
"`have hxy : (x + y) ^ 2 = (x ^ 2 + y ^ 2) + 2 * (x * y) := by ring_nf`?"
msgstr ""

#: Game.Levels.L7Levels.L03_SeqInvLim
msgid "SeqInvLim"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "The `field_simp` tactic tries to clear denominators, if it can figure out that the denominators are non-zero (or in the case of inequalities, positive)."
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! 🎉"
msgstr ""

#: Game.Levels.L12Levels.L01_Choose
msgid "# Level 2: Enhanced `Choose`\n"
"\n"
"Do you know the \"Twin Prime Conjecture\"?\n"
"A number `n : ℕ` is called a Twin Prime if both `n`\n"
"and `n+2` are prime numbers. Let's call this property\n"
"`p : ℕ → Prop`. So `p` is a function that takes a\n"
"natural number `n` and returns `p (n) = ` Yes/No, depending on whether `n` is a twin prime. The Twin Prime Conjecture says that there are infinitely many twin primes; that is, for any bound `N`, no matter how large,\n"
"there is always at least one `n > N` for which `p (n)` holds. We would state the conjecture like this:\n"
"\n"
"`h : ∀ N, ∃ n > N, p n`\n"
"\n"
"Now suppose that we have a hypothesis like this, for some abstract property `p` (if you like, you're welcome to keep thinking of `p n` as testing whether `n` is a twin prime). Given that there are arbitrarily large `n`'s for which `p n` holds, how do I get my hands on a subsequence `σ : ℕ → ℕ`, so that, along the subsequence, `p (σ n)` holds, for all `n`?\n"
"\n"
"The idea is that you should interpret `h` as a collection of **functions**. Given a natural number `N`,  the hypothesis `h` will produce a `n` for you, but that `n` is a function of `N`, so we should really write `n = n (N)`. But that's not all! The hypothesis `h` also contains a *proof* that `n (N) > N` for all `N`. Do you see why the statement of `h` implies\n"
"the existence of such a function? And lastly, `h` also gives us a proof of the fact that, for all `N`,\n"
"`p (n (N))` holds. So `n (N)` is (almost) our desired sequence! (Since it's funny to write `n (N)`, let's rename `n` to `τ`, so we can write `τ (N)`.) The way in Lean to go from `h` to these sequences is to invoke a familiar tactic: `choose`! If you write:\n"
"\n"
"`choose τ hτBnd hτP using h`\n"
"\n"
"then Lean will add to your goal state:\n"
"\n"
"`τ : ℕ → ℕ`\n"
"\n"
"`hτBnd : ∀ N, τ (N) > N`\n"
"\n"
"`hτP : ∀ N, p (N)`\n"
"\n"
"Isn't that cool?! Now you should be able to use the idea from the last level to make the desired subsequence `σ`,\n"
" but you'll need to think about how *exactly* to make it work..."
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "If you're stuck at this point, let me remind you that, in a previous level, the Goal was: `∀ ε > 0, BlahBlah`, and\n"
"after `intro ε`, the Goal became `ε > 0 → BlahBlah`.\n"
"Then what did you do?..."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "Write `choose c hc using h`, then you should be able to finish it yourself."
msgstr ""

#: Game.Levels.L14Levels.L01_BolzanoWeierstrass
msgid "If a sequence `a : ℕ → X` (where `X` could be `ℚ` or `ℝ`) is bounded, then it has a subsequence which is Cauchy."
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "Given `ε` and the fact that `0 < ε`, the theorem `ArchProp` claims the existence of `N : ℕ` so that `1 / ε < N`. This is a formalization of the classical Archimedean Property."
msgstr ""

#: Game.Levels.L12Lecture
msgid "Lecture 12: Cauchy Sequences II"
msgstr ""

#: Game.Levels.L10Pset.L10Pset3
msgid "# Problem 2:\n"
"\n"
"Finish the proof of `ProdLim`."
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "# Level 1: Doubling Convergence\n"
"\n"
"After conquering the constant sequence, let's up our game: if a sequence converges, then doubling that sequence also converges, and converges to double the original limit.\n"
"\n"
"## The Factory Scaling Challenge\n"
"\n"
"Imagine our Machinist receives a challenge from the Engineer: 'Please double all the lengths, but maintain the same quality standards.' How should the Machinist respond?\n"
"\n"
"If the Engineer demands the doubled lengths be within $\\varepsilon$ of $2L$, the Machinist can't just demand that the original process meet the original tolerance $\\varepsilon$, because\n"
"\n"
"`|2 * a (n) - 2 * L| < 2 * ε`,\n"
"\n"
"not `ε`. Instead, we must be more clever. Can you think of what to do?\n"
"\n"
"That's right, the `ε` in the original process\n"
"is *arbitrary*, so we can play with it!\n"
"If we could get the original process can guarantee output within $\\varepsilon/2$ of $L$, then doubling that output will be within $\\varepsilon$ of $2L$.\n"
"\n"
"This is the key insight: **when scaling by a constant, we need to scale our tolerance demands inversely**.\n"
"\n"
"## The Mathematical Setup\n"
"\n"
"Suppose we have:\n"
"- A sequence $a : \\mathbb{N} \\to \\mathbb{R}$ that converges to $L$\n"
"- A sequence $b : \\mathbb{N} \\to \\mathbb{R}$ with the property that $b(n) = 2 \\cdot a(n)$ for all $n$\n"
"\n"
"We want to prove that $b$ converges to $2 \\cdot L$.\n"
"\n"
"## Key Insight: Inverse Tolerance Scaling\n"
"\n"
"The crucial observation is that:\n"
"\n"
"$|b(n) - 2L| = |2 \\cdot a(n) - 2L| = 2 \\cdot |a(n) - L|$\n"
"\n"
"So if we want $|b(n) - 2L| < \\varepsilon$, we need $2 \\cdot |a(n) - L| < \\varepsilon$, which means $|a(n) - L| < \\varepsilon/2$.\n"
"\n"
"This is exactly what we can get from the convergence of $a$!\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"**Absolute Value of Products**:\n"
"You'll need the new theorem `abs_mul` which states that for any real numbers $x$ and $y$:\n"
"\n"
"$|x \\cdot y| = |x| \\cdot |y|$.\n"
"\n"
"To use this theorem, you may find it convenient to\n"
"make a new hypothesis using `have` and then `rewrite` by that hypothesis. That is, you can say,\n"
"\n"
"`have NewFact : |Something * SomethingElse| =\n"
"|Something| * |SomethingElse| :=\n"
"by apply abs_mul`\n"
"\n"
"and then `rewrite [NewFact]` will replace `|Something * SomethingElse|` by `|Something| * |SomethingElse|` (either at the Goal, or `at` a hypothesis, if you so specify).\n"
"\n"
"## Your Strategic Approach\n"
"\n"
"1. Unfold the definition of convergence for the goal\n"
"2. Given any $\\varepsilon > 0$, use the convergence of $a$ with tolerance $\\varepsilon/2$. You may find it useful to separately prove the inequality `0 < ε / 2` -- which\n"
"tactic do you think will help with that?\n"
"3. Extract the witness $N$ from the convergence of $a$\n"
"4. Use the same $N$ for your sequence $b$\n"
"5. Apply the scaling hypothesis and use `abs_mul` to relate $|b(n) - 2L|$ to $|a(n) - L|$\n"
"6. Use the convergence bound for $a$ to conclude\n"
"\n"
"## Why This Pattern Matters\n"
"\n"
"This proof introduces the important technique of **inverse scaling** for tolerances. When you scale a sequence by a constant $c$, you need to scale your tolerance demands by $1/c$. This principle will appear again when you study:\n"
"- Products of sequences (where both factors contribute to the error)\n"
"- Derivatives (where the limit definition involves scaling by $h$)\n"
"- Integration (where Riemann sums involve scaling by partition widths)\n"
"\n"
"The ability to manage how constants affect convergence is fundamental to all of analysis!"
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "The `linarith` tactic won't work\n"
"yet, because it'll get stuck on that `|2|`; do you remember what to do\n"
"to normalize the numerical value to just `2`?"
msgstr ""

#: Game.Levels.L10Levels.L08_Mono
msgid "If a sequence `a` converges to `L` and `σ` is a subsequence, then `a ∘ σ` also converges to `L`."
msgstr ""

#: Game.Levels.L12Levels.L01_MonotoneBdd
msgid "If a sequence `a : ℕ → X` (where `X` can be `ℚ` or `ℝ`) is monotone and bounded, then it is Cauchy."
msgstr ""

#: Game.Levels.L7Levels.L03_SeqInvLim
msgid "If `0 < |x|`, then `x ≠ 0`."
msgstr ""

#: Game.Levels.L9Levels.L04_FiniteSums
msgid "If your hypotheses lead to a contradiction, (for example: if one of your hypotheses is that `h : n < 0` where `n : ℕ` is a natural number) then the `contradiction` tactic closes the goal."
msgstr ""

#: Game.Levels.L9Levels.L05_BddOfConv
msgid "If `a : ℕ → ℝ` is a sequence which converges to a non-zero limit, then it is bounded.\n"
"See also `BddOfConv` which assumes nothing about the limit."
msgstr ""

#: Game.Levels.L13Levels.L03_MonotoneSubseq
msgid "If `¬ (m ≤ n)`, then `n < m`."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "Try starting with `change ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, |a n - L| < ε`"
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "And finally, this is where the powerful `linarith` tactic can take over. Remember to feed it (in brackets) the hypothesis (or hypotheses, separated by commas) which you want to manipulate to turn into the Goal."
msgstr ""

#: Game.Levels.L13Levels.L03_MonotoneSubseq
msgid "If a sequence `a : ℕ → X` (where `X` could be `ℚ` or `ℝ`) does not have unbounded peaks, then it has a `Monotone` subsequence."
msgstr ""

#: Game.Levels.L6Levels.L03_DotNotation
msgid "# Level 4: Dot Notation - Accessing Parts of Complex Information\n"
"\n"
"Now that you've learned to construct \"and\" statements with `split_ands` and make strategic choices with \"or\" statements using `left` and `right`, it's time to learn how to efficiently extract information from complex hypotheses you already have.\n"
"\n"
"Often in mathematics, you'll be given a hypothesis that contains multiple pieces of information bundled together. For instance, you might know that \"x = 2 AND y = 3\" but only need the fact that \"y = 3\" for your current goal. Rather than using lengthy tactics to unpack this information, Lean provides an elegant shorthand: dot notation.\n"
"\n"
"Think of dot notation like accessing specific files in a well-organized filing cabinet. If you have a folder labeled `h` that contains multiple documents, you can quickly grab the second document with `h.2` instead of having to open the folder, sort through all the papers, and extract what you need manually.\n"
"\n"
"This notation becomes especially powerful when dealing with complex mathematical objects. In real analysis, we often work with properties that have multiple components—a sequence might be both bounded AND monotonic, or a function might be both continuous AND differentiable. Dot notation lets us access exactly the property we need, when we need it.\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"**Dot notation**: When you have a hypothesis `h : P ∧ Q`, you can access the first part with `h.1` (which gives you `P`) and the second part with `h.2` (which gives you `Q`).\n"
"\n"
"Note that for longer conjunctions like `P ∧ Q ∧ R`, `h.1` gives `P` as expected, but\n"
"`h.2` gives `Q ∧ R`. That's because there are hidden parentheses: `P ∧ Q ∧ R = P ∧ (Q ∧ R)`. So how do you get to `Q` alone? Easy: dot notation! Writing `h.2.1` gives `Q`, and `h.2.2` gives `R`."
msgstr ""

#: Game.Levels.L11Levels.L02_IsCauchyOfSum
msgid "# Excellent work! Cauchy sequences are closed under addition!\n"
"\n"
"You've just proven that the set of Cauchy sequences forms a well-behaved algebraic structure—they can be added together and the result is still Cauchy.\n"
"\n"
"## What this means\n"
"\n"
"This theorem shows that the Cauchy property is **preserved by addition**. This is crucial because:\n"
"\n"
"- We can build more complex Cauchy sequences from simpler ones\n"
"- When we eventually construct the real numbers as equivalence classes of Cauchy sequences, we'll need to know that addition is well-defined\n"
"- The Cauchy sequences form what algebraists call a **vector space** (or at least a subspace of all sequences)\n"
"\n"
"## The Pattern\n"
"\n"
"Notice how similar this proof was to proving that sums of convergent sequences converge:\n"
"- Split `ε` into `ε / 2` for each sequence\n"
"- Use the triangle inequality to separate the sum\n"
"- Combine the estimates\n"
"\n"
"The key difference? **No limits appeared anywhere!** The Cauchy property is entirely self-contained.\n"
"\n"
"Ready for the next level!"
msgstr ""

#: Game.Levels.L4PsetIntro
msgid "# Problem Set 4\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L8Pset.L8Pset2
msgid "# Problem 2\n"
"\n"
"We proved in class that `n < 2 ^ n`. It's even true that `n ^ 2 ≤ 2 ^ n`, but only for `n` sufficiently large (how large?).\n"
"\n"
"Look at the problem statement. Note how we've implemented induction starting somewhere other than zero: by shifting the argument by that amount.\n"
"\n"
"Hint: The result from Problem 1 might come in handy..."
msgstr ""

#: Game.Levels.L10Levels.L07_Order
msgid "Excellent work! You've proven that limits respect inequalities.\n"
"\n"
"**What We Learned:**\n"
"\n"
"The Order Limit Theorem tells us that **weak inequalities pass to the limit**:\n"
"- If `a n ≤ K` for all `n` and `a n → L`, then `L ≤ K`\n"
"\n"
"**Why Contradiction Works Here:**\n"
"\n"
"This is a great example of when proof by contradiction is the natural approach. We want to prove `L ≤ K`, which is hard to show directly. But assuming `L > K` gives us a concrete positive number `L - K` that we can use as `ε` in the convergence definition. The contradiction writes itself!\n"
"\n"
"**The Symmetric Result:**\n"
"\n"
"There's a symmetric version (left as an exercise): if `K ≤ a n` for all `n` and `a n → L`, then `K ≤ L`. This says sequences bounded **below** have limits bounded below.\n"
"\n"
"**Important Limitation:**\n"
"\n"
"Remember: **strict inequalities don't pass to the limit!**\n"
"\n"
"If `a n < K` for all `n`, we can only conclude `L ≤ K`, not `L < K`.\n"
"\n"
"Counter-example: `a n = 1/n` satisfies `0 < a n` for all `n`, but `lim a n = 0`.\n"
"\n"
"The limit can equal the boundary even when the sequence never touches it!\n"
"\n"
"**Coming Up: Applications**\n"
"\n"
"The Order Limit Theorem is the foundation for:\n"
"- **Squeeze Theorem (Sandwich Theorem):** If `a n ≤ b n ≤ c n` and `a n → L` and `c n → L`, then `b n → L`\n"
"- **Monotone Convergence Theorem:** Bounded monotone sequences converge\n"
"- **Comparison tests** for series\n"
"- Many other fundamental results in analysis\n"
"\n"
"This theorem lets us compare sequences and transfer information about one sequence to another via inequalities. Very powerful!"
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "Prove that constant multiples of convergent sequences converge to the constant multiple of the limit.\n"
"This is the Machinist's response to scaling demands: 'If you want double the output with the same tolerance, I need half the tolerance on the original process!'"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "`(a : ℕ → ℝ) (L : ℝ) := ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, |a n - L| < ε`\n"
"\n"
"For a sequence `a : ℕ → ℝ` and a real number `L : ℝ`, we say that `SeqLim a L` holds if: for every `ε > 0`, there exists `N : ℕ` such that for all `n ≥ N`, we have `|a n - L| < ε`."
msgstr ""

#: Game.Levels.L13Pset.L13Pset1
msgid "Prove `AntitoneSubseq_of_UnBddPeaks`"
msgstr ""

#: Game.Levels.L12Levels.L00_SubseqIterate
msgid "If a sequence `σ : ℕ → ℕ` grows faster than the identity, `n < σ n`,\n"
"then the orbit of any base point `n₀ : ℕ` under `σ` -- this means the sequence `n₀, σ n₀, σ^[2] n₀, ...` -- is a `Subseq`, that is, is strictly increasing."
msgstr ""

#: Game.Levels.L7Levels.L00_Uniqueness
msgid "Uniqueness of Limits"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "The `exact_mod_cast` tactic is similar to `apply`, except it automatically handles type coercions that would otherwise require manual casting."
msgstr ""

#: Game.Levels.L6Levels.L00_SumOfSeqs
msgid "# 🎉 Outstanding! 🎉\n"
"\n"
"You've just proven one of the fundamental theorems of analysis! Let's celebrate what you accomplished and understand why this result is so powerful.\n"
"\n"
"**Why This Matters:**\n"
"This theorem and others like it are the foundation for all of calculus! Every time we differentiate or integrate a sum, we're implicitly using arguments of this kind.\n"
"\n"
"**The Deeper Insight:**\n"
"Notice how the proof required more than just intuition. The 'obvious' fact that sums of convergent sequences converge needed careful epsilon management. This is the hallmark of rigorous analysis: making intuitive ideas completely precise.\n"
"\n"
"## Check in, in Natural Language\n"
"\n"
"Yet again, let's step back from the formal Lean proof and understand what we just proved in plain English.\n"
"\n"
"**Theorem (in natural language):** If two sequences of real numbers converge to their respective limits, then the sequence formed by adding corresponding terms also converges, and its limit is the sum of the original limits.\n"
"\n"
"**Proof:** Suppose sequences $a(n)$ and $b(n)$ converge to $L$ and $M$ respectively, and we want to show that $c(n) = a(n) + b(n)$ converges to $L + M$.\n"
"\n"
"By definition, we need to show that for any tolerance $\\varepsilon > 0$, we can find a point $N$ such that for all $n \\geq N$, we have $|c(n) - (L + M)| < \\varepsilon$.\n"
"\n"
"Since $a(n)$ converges to $L$, we can find $N_1$ such that $|a(n) - L| < \\varepsilon/2$ for all $n \\geq N_1$.\n"
"Since $b(n)$ converges to $M$, we can find $N_2$ such that $|b(n) - M| < \\varepsilon/2$ for all $n \\geq N_2$.\n"
"\n"
"Let $N = N_1 + N_2$ (any number that's at least as large as both $N_1$ and $N_2$ would work). Then for any $n \\geq N$:\n"
"\n"
"$$|c(n) - (L + M)| = |(a(n) + b(n)) - (L + M)| = |(a(n) - L) + (b(n) - M)|$$\n"
"\n"
"By the triangle inequality, this is at most:\n"
"$$|a(n) - L| + |b(n) - M| < \\frac{\\varepsilon}{2} + \\frac{\\varepsilon}{2} = \\varepsilon$$\n"
"\n"
"Therefore, $c(n)$ converges to $L + M$. **QED**"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "If there exists a point where f equals 2, then there exists a point where f² equals 4."
msgstr ""

#: Game.Levels.L9Levels.L05_BddOfConv
msgid "`(a : ℕ → X) := ∃ M > 0, ∀ n, |a n| ≤ M`\n"
"\n"
"  A sequence `a : N → X` (where `X` could be `ℚ` or `ℝ`) is bounded (`SeqBdd` holds) if there exists some positive\n"
"`M : X` so that `|a n| ≤ M`, for all `n`."
msgstr ""

#: Game.Levels.L9Levels.L04_FiniteSums
msgid "Given a function `f : ℕ → ℝ` and a natural number `N`, `sum_range_succ f n` says that:\n"
"`∑ n ∈ range (N + 1), f n = ∑ n ∈ range N, f n + f N`."
msgstr ""

#: Game.Levels.L3Pset.L3Pset1
msgid "Prove the full Archimedean Property."
msgstr ""

#: Game.Levels.L7Pset.L7Pset1
msgid "If `a : ℕ → ℝ` converges to `L` and `L ≠ 0`, then `|a n|` is eventually bounded by `2 * |L|`."
msgstr ""

#: Game.Levels.L7PsetIntro
msgid "# Problem Set 7\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "Doubling a Convergent Sequence"
msgstr ""

#: Game.Levels.L8Pset.L8Pset3
msgid "# Problem 3\n"
"\n"
"Prove that `n (n + 1) (2 n + 1)` is always divisible by `6`. (Hint: induction.)"
msgstr ""

#: Game.Levels.L7Levels.L03_SeqInvLim
msgid "# Level 4: Reciprocals of Convergent Sequences — Big Boss Level\n"
"\n"
"One of the most important limit theorems concerns reciprocals: if a sequence converges to\n"
"a nonzero limit, then the sequence of reciprocals converges to the reciprocal of the limit.\n"
"This result is crucial for proving theorems about quotients and rational functions.\n"
"\n"
"This is a **Big Boss level**—it will require you to synthesize multiple techniques you've\n"
"developed throughout this lecture: working with nonzero limits, manipulating complex\n"
"algebraic expressions, and carefully choosing your epsilon strategy.\n"
"\n"
"## What We're Proving\n"
"\n"
"**Theorem:** If `a : ℕ → ℝ` converges to `L` with `L ≠ 0`, and `b : ℕ → ℝ` is defined\n"
"by `b n = 1 / a n` for all `n`, then `b` converges to `1 / L`.\n"
"\n"
"This is the most technically challenging proof in this lecture.\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"### `abs_div`\n"
"For any real numbers `x` and `y` (with `y ≠ 0`), we have `|x / y| = |x| / |y|`.\n"
"\n"
"### `nonzero_of_abs_pos`\n"
"If `0 < |x|`, then `x ≠ 0`.\n"
"\n"
"## Hints\n"
"\n"
"Think about what you've proven in the previous levels:\n"
"- How can you ensure that `a n ≠ 0` eventually, so the reciprocals are well-defined?\n"
"- What happens when you try to bound `|1/a n - 1/L|`? Can you get a common denominator?\n"
"- How should you choose your epsilon when applying the convergence of `a` to `L`?\n"
"- What role does the lower bound on `|a n|` play in controlling the reciprocals?\n"
"\n"
"The key is finding the right epsilon and carefully managing the algebraic manipulations\n"
"involving fractions. You have all the tools you need—now it's time to put them together!"
msgstr ""

#: Game
msgid "# Welcome to Real Analysis, The Game!\n"
"\n"
"This course is currently being developed for Rutgers University Math 311H by [Alex Kontorovich](https://math.rutgers.edu/~alexk).\n"
" Please email alex.kontorovich@rutgers.edu for suggestions/corrections,\n"
"or better yet, post a PR/issue to\n"
"https://github.com/AlexKontorovich/RealAnalysisGame.\n"
"\n"
"For the main course website, go to: https://alexkontorovich.github.io/2025F311H.\n"
"\n"
"This course takes you through an Introduction to the Real Numbers, rigorous `ε`-`δ` Calculus,\n"
"and basic Point-Set Topology.\n"
"To get started, click on\n"
"**\"Level 1: The Story of Real Analysis\"**, and good luck!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "The `rewrite` tactic"
msgstr ""

#: Game.Levels.L7Levels.L02_SeqOfAbs
msgid "If `a : ℕ → ℝ` converges to `L`, and `b : ℕ → ℝ` is its absolute value, `b n = |a n|` for all `n`, then `b` converges to `|L|`."
msgstr ""

#: Game.Levels.L7Levels.L03_SeqInvLim
msgid "If `a : ℕ → ℝ` converges to `L`, and `b : ℕ → ℝ` is its inverse, `b n = 1 / a n` for all `n`, then `b` converges to `1 / L`, provided `L ≠ 0`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "Excellent! You've learned the `ring_nf` tactic.\n"
"\n"
"This tactic is incredibly powerful for algebraic manipulations. It automatically handles all the tedious algebra that would take many steps to do by hand.\n"
"\n"
"Your toolkit now includes:\n"
"- `apply hypothesis_name` for when a hypothesis matches your goal\n"
"- `rfl` for proving something equals itself\n"
"- `rewrite [hypothesis_name]` for rewriting using equalities\n"
"- `ring_nf` for algebraic simplifications and expansions\n"
"\n"
"As we move into real analysis proper, you'll find that `ring_nf` is invaluable for dealing with polynomial expressions, which appear everywhere in calculus!"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Since 1 / ε < N, we get N > 0: `have Npos : (0 : ℝ) < N := by linarith [f3, eps_inv_lt_N]`. Again we need to be specific about the casting."
msgstr ""

#: Game.Levels.L6Pset.L6Pset2
msgid "# Problem 2\n"
"\n"
"You know that `h : x = 2 ∧ y = 3 ∧ z = 4`.\n"
"Your goal is to show that: `z = 4`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "The specialize tactic"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "Introduction to Lean"
msgstr ""

#: Game.Levels.L1Pset.L1Pset2
msgid "Show that there exists a constant `c` so that, for any real numbers `x` and `y` with `x ^ 2 + y ^ 2 = 2` and `x * y = 1`, we have `(x + y) ^ 2 = c`."
msgstr ""

#: Game.Levels.L10Pset.L10Pset7
msgid "# Problem 6:\n"
"\n"
"Show that if a sequence has two subsequences that converge to\n"
"different limits, then the sequence itself cannot converge."
msgstr ""

#: Game.Levels.L10Levels.L09_Subseq
msgid "# Level 4: Subsequence Example\n"
"\n"
"We've proven that `(-1)^n` does not converge—it oscillates between -1 and 1 forever. But even though the full sequence diverges, it has subsequences that converge!\n"
"\n"
"**The Goal:** Exhibit a subsequence of `a n = (-1)^n` that converges to some limit `L`.\n"
"\n"
"**The Idea:** Extract the **even-indexed terms**.\n"
"\n"
"Define `σ(n) = 2*n`, which picks out indices 0, 2, 4, 6, 8, ...\n"
"\n"
"Then:\n"
"- `(a ∘ σ)(0) = a(0) = (-1)^0 = 1`\n"
"- `(a ∘ σ)(1) = a(2) = (-1)^2 = 1`\n"
"- `(a ∘ σ)(2) = a(4) = (-1)^4 = 1`\n"
"- `(a ∘ σ)(n) = a(2n) = (-1)^(2n) = 1` for all `n`\n"
"\n"
"So the subsequence is constant: `1, 1, 1, 1, ...` which clearly converges to 1!\n"
"\n"
"**New Tool: The `let` Tactic**\n"
"\n"
"To define `σ` within our proof, we use the `let` tactic. This creates a new variable or function/sequence (unlike `have`, which proves propositions).\n"
"\n"
"**The `fun` Keyword:**\n"
"\n"
"To create a function in Lean, we use `fun`:\n"
"```\n"
"fun x ↦ expression\n"
"```\n"
"This creates a function that takes input `x` and returns `expression`.\n"
"\n"
"The arrow `↦` (type `\\mapsto` or just use `=>`) separates input from output.\n"
"\n"
"Example: `fun x ↦ x ^ 2` is the squaring function.\n"
"\n"
"**Combining `let` and `fun`:**\n"
"\n"
"```\n"
"let σ : ℕ → ℕ := fun n ↦ 2 * n\n"
"```\n"
"\n"
"This defines a function `σ : ℕ → ℕ` by `σ(n) = 2*n`.\n"
"\n"
"**The Proof Structure:**\n"
"\n"
"We need to prove `∃ σ L, Subseq σ ∧ SeqLim (a ∘ σ) L`.\n"
"\n"
"1. Define `σ(n) = 2*n` using `let`\n"
"2. Use `σ` and `L = 1` as our witnesses\n"
"3. Prove two things:\n"
"   - `σ` is a subsequence (strictly increasing)\n"
"   - `a ∘ σ` converges to 1\n"
"\n"
"For part 2, compute `a(2*n) = (-1)^(2*n) = 1`, so `|a(2*n) - 1| = 0 < ε` for any `ε > 0`.\n"
"\n"
"**The Deeper Lesson:**\n"
"\n"
"Even though `(-1)^n` diverges, we can extract convergent behavior by focusing on the even terms (or odd terms). This shows that **subsequences can be better behaved than the original sequence**.\n"
"\n"
"The fact that the even and odd subsequences converge to *different* limits (1 and -1) is exactly what proves the original sequence diverges!"
msgstr ""

#: Game.Levels.L8Levels.L03_Induction'
msgid "NotEven"
msgstr ""

#: Game.Levels.L3PsetIntro
msgid "# Problem Set 3\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "Let's compare now to the purely natural language proof:\n"
"\n"
"## Natural Language Proof of the Archimedean Property\n"
"\n"
"**Theorem**: For any positive real number ε > 0, there exists a natural number N such that 1 / ε < N.\n"
"\n"
"**Proof**:\n"
"Let ε > 0 be given. We need to find a natural number N such that 1 / ε < N.\n"
"\n"
"Use the value N = ⌈1 / ε⌉₊ + 1, where ⌈·⌉₊ denotes the natural number ceiling function.\n"
"\n"
"Since ε > 0, we have 1 / ε > 0. By the definition of the natural number ceiling function, we know that:\n"
"\n"
"1 / ε ≤ ⌈1 / ε⌉₊\n"
"\n"
"Now, since ⌈1 / ε⌉₊ is a natural number and N = ⌈1 / ε⌉₊ + 1, we have:\n"
"\n"
"⌈1 / ε⌉₊ < ⌈1 / ε⌉₊ + 1 = N\n"
"\n"
"Combining these inequalities, we get that:\n"
"\n"
"1 / ε ≤ ⌈1 / ε⌉₊ < N\n"
"\n"
"Therefore, 1 / ε < N, which completes the proof. □\n"
"\n"
"**Significance**: The Archimedean Property is fundamental to analysis because it ensures that the real numbers have no \"infinite\" or \"infinitesimal\" elements. It guarantees that we can always find natural numbers large enough to dominate any given positive real number when we take their reciprocals. This property is essential for many limit processes and is equivalent to the completeness of the real numbers in certain formulations of real analysis.\n"
"\n"
"## Review of Common Pitfalls\n"
"\n"
"- **Don't use the regular ceiling function `⌈·⌉`** - it returns integers, not natural numbers!\n"
"- **Watch out for casting issues** - if `bound` isn't working, try `push_cast` first\n"
"- **The addition `⌈1 / ε⌉₊ + 1` happens in `ℕ`**, then gets cast to `ℝ` - this is why we need `push_cast`\n"
"\n"
"**Historical Note**: While often attributed to Archimedes (c. 287-212 BCE), this property was likely known to Eudoxus (c. 408-355 BCE) and appears in Euclid's *Elements*. Archimedes used a version of this principle in his method of exhaustion, particularly in calculating areas and volumes by approximating them with polygons of increasing numbers of sides."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "If we know that $x = 5$, then we can prove that $x = 5$."
msgstr ""

#: Game.Levels.L12PsetIntro
msgid "Pset 12"
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "Apply the absolute value of products: `have abs_factor : |2 * (a n - L)| = |2| * |a n - L| := by apply abs_mul`"
msgstr ""

#: Game.Levels.L7Levels.L04_ByCases
msgid "# Level 5: Case Analysis Without Existing Hypotheses\n"
"\n"
"## The Need for `by_cases`\n"
"\n"
"You've already learned how to use `cases'` to handle disjunctions when you have a hypothesis\n"
"`h : P ∨ Q`. This allows you to split your proof into two branches: one where you assume `P`\n"
"is true, and another where you assume `Q` is true.\n"
"\n"
"But what if you need to perform case analysis on a statement that isn't already among your\n"
"hypotheses? Sometimes you need to consider whether a certain proposition is true or false,\n"
"even when you haven't been explicitly told which case holds.\n"
"\n"
"This is where the **law of excluded middle** comes in: for any proposition `P`, either `P` is\n"
"true or `¬P` is true. The `by_cases` tactic allows you to exploit this fundamental logical\n"
"principle directly in your proofs.\n"
"\n"
"Just so you know: the law of excluded middle is somewhat controversial in certain mathematical\n"
"circles. \"Constructivist\" mathematicians argue that to prove `P ∨ ¬P`, you should need to either\n"
"construct a proof of `P` or construct a proof of `¬P`, not merely assert that one of these must be true.\n"
"However, among mainstream mathematicians (and in classical logic, which Lean allows),\n"
"the law of excluded middle is accepted without question. For our purposes in real analysis,\n"
"we'll use it freely, as it's an incredibly powerful and natural tool for organizing proofs.\n"
"\n"
"## How by_cases Works\n"
"\n"
"The `by_cases` tactic has the syntax:\n"
"\n"
"`by_cases h : fact`\n"
"\n"
"where `h` is the name you choose for the new hypothesis, and `fact` is the proposition you\n"
"want to analyze. This creates two subgoals:\n"
"- **First subgoal:** Assume `fact` is true, giving you hypothesis `h : fact`\n"
"- **Second subgoal:** Assume `fact` is false, giving you hypothesis `h : ¬fact`\n"
"\n"
"You must prove your goal in both cases.\n"
"\n"
"## When to Use by_cases\n"
"\n"
"Use `by_cases` when:\n"
"- You need to consider whether some condition holds, but it's not already a hypothesis\n"
"- Different proof strategies apply depending on whether a statement is true or false\n"
"- You need to handle edge cases (like checking if a number equals zero)\n"
"- You want to prove a theorem with weaker assumptions by splitting into cases\n"
"\n"
"## A Motivating Example\n"
"\n"
"In this level, we'll prove a generalization of `EventuallyGeHalfLimPos`. The previous version\n"
"required the assumption `L ≠ 0`. But what if we want to prove the result without that\n"
"assumption? We can use `by_cases` to split into two cases:\n"
"- If `L = 0`, the result is trivially true (since `|L|/2 = 0`)\n"
"- If `L ≠ 0`, we can apply our previous theorem\n"
"\n"
"This demonstrates how `by_cases` allows us to handle all possibilities systematically, making\n"
"our theorems more general and our proofs more robust.\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"### `by_cases`\n"
"The `by_cases` tactic allows you to split a proof into two cases based on whether a\n"
"proposition is true or false.\n"
"\n"
"**Syntax:** `by_cases h : P`\n"
"- Creates two subgoals\n"
"- First subgoal has hypothesis `h : P`\n"
"- Second subgoal has hypothesis `h : ¬P`"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "The `apply` tactic solves a goal when one of the hypotheses is the same as the goal. The syntax is `apply hypothesis_name`"
msgstr ""

#: Game.Levels.L6Pset.L6Pset5
msgid "Done. (Hopefully you didn't do that by hand, but rather quoted -- twice -- a theorem that we recently proved?)"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "# Extracting information from existential quantifiers\n"
"\n"
"Now let's learn the counterpart to `use`. You know that if you have `∃` in the goal, you write `use` to provide a specific value.\n"
"\n"
"But suppose you have a *hypothesis* that says \"there exists a real number `c` such that `f (c) = 2`\". In Lean, this looks like:\n"
"`h : ∃ (c : ℝ), f c = 2`\n"
"\n"
"And say you want to prove that \"there exists a real number `c` such that `(f c)^2 = 4`\".\n"
"\n"
"Again, you can't just say `apply h` because these are different statements.\n"
"If you know from `h` that at least one such `c` exists, how do you *choose* one?\n"
" The name of this command is... `choose`.\n"
"\n"
"The syntax for `choose` is as follows:\n"
"\n"
"`choose c hc using h`.\n"
"\n"
"You need to give a name to both the value of `c`, and to the hypothesis with which `c` is bundled. Here we named it `hc` (a hypothesis about `c`).\n"
"\n"
"You should be able to figure out how to solve the goal from here."
msgstr ""

#: Game.Levels.L12Levels.L02_IterateGap
msgid "## What You've Accomplished\n"
"\n"
"You've proven the technical engine that drives the fundamental theorem about bounded monotone sequences. This lemma reveals exactly how persistent gaps accumulate under iteration - linearly, predictably, and inevitably.\n"
"\n"
"## The Mathematical Machinery\n"
"\n"
"The proof demonstrates how several sophisticated techniques work together:\n"
"- **Induction** to handle the iterative structure\n"
"- **Monotonicity** to control the relationships between intermediate points\n"
"- **The gap condition** applied at each iteration step\n"
"- **Telescoping inequalities** to accumulate the growth\n"
"\n"
"This is real analysis in action: taking local properties and scaling them up to global phenomena through careful mathematical reasoning.\n"
"\n"
"## Why Linear Accumulation Matters\n"
"\n"
"The key insight is that gaps don't just accumulate - they accumulate *linearly*. This linear growth `k * ε` is what makes the contradiction with boundedness inevitable.\n"
"\n"
"## Completing the Circle\n"
"\n"
"With this lemma proven, the main theorem is now complete. You've seen how:\n"
"1. **Level 1:** Iteration extracts monotonic subsequences from chaotic growth\n"
"2. **Level 2:** Contradiction converts persistent gaps into bounded violation\n"
"3. **Level 3:** Technical precision makes the gap accumulation rigorous\n"
"\n"
"Each piece was essential, and together they form a complete argument about a fundamental property of ordered systems.\n"
"\n"
"## The Broader Pattern\n"
"\n"
"You've mastered a proof technique that appears throughout analysis: assume pathological behavior exists, extract witnesses using choice principles, iterate to amplify the pathology until it contradicts known constraints. This pattern - *local pathology + iteration + contradiction* - is one of the most powerful tools in real analysis.\n"
"\n"
"The orbit construction from Level 1, the contradiction framework from Level 2, and the inductive gap accumulation from Level 3 will serve you well in advanced mathematics."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "The binomial expansion: $(x + y)^3 = x^3 + 3x^2y + 3xy^2 + y^3$."
msgstr ""

#: Game.Levels.L6Levels.L06_Squeeze
msgid "Big Boss : Squeeze Theorem"
msgstr ""

#: Game.Levels.L1Pset.L1Pset4
#: Game.Levels.L3Pset.L3Pset4
#: Game.Levels.L6Pset.L6Pset4
#: Game.Levels.L8Pset.L8Pset4
#: Game.Levels.L10Pset.L10Pset5
msgid "Problem 4"
msgstr ""

#: Game.Levels.L10Pset.L10Pset2
msgid "# Problem 1:\n"
"\n"
"\n"
"Prove the Theorem `LimZeroTimesBdd`: if a sequence `a n` converges to `0`, and the sequence `b n` is merely bounded (not necessarily convergent!), then the product\n"
"`a * b` converges to `0`."
msgstr ""

#: Game.Levels.L12Levels.L01_MonotoneBdd
msgid "Monotone and Bounded Implies Cauchy"
msgstr ""

#: Game.Levels.L10Levels.L08_Mono
msgid "Subsequences"
msgstr ""

#: Game.Levels.L9Levels.L04_FiniteSums
msgid "Finite Sums"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "# Level 2: Our First Real Limit\n"
"\n"
"*Congratulations!* You've just proved the Archimedean Property. Now let's use it to prove something genuinely interesting: our first non-trivial limit.\n"
"\n"
"## The Goal: Proving that `1 / n → 0`\n"
"\n"
"We want to prove that the sequence `a(n) = 1 / n` converges to `0` as `n` approaches infinity. This is intuitively obvious—as `n` gets larger, `1 / n` gets smaller and approaches `0`. But how do we make this rigorous using the `ε`-`N` definition of limits?\n"
"\n"
"**Theorem**: The sequence `a(n) = 1 / n` converges to `0`.\n"
"\n"
"This might seem straightforward, but let's see it as a test of the definition.\n"
"\n"
"## Recall: The Definition of Sequential Convergence\n"
"\n"
"A sequence `a : ℕ → ℝ` converges to a limit `L` (written `SeqLim a L`) if:\n"
"\n"
"**For every `ε > 0`, there exists `N : ℕ` such that for all `n ≥ N`, `|a(n) - L| < ε`**\n"
"\n"
"In formal notation: `∀ ε > 0, ∃ N, ∀ n ≥ N, |a(n) - L| < ε`\n"
"\n"
"For our specific case with `a(n) = 1 / n` and `L = 0`, this becomes:\n"
"`∀ ε > 0, ∃ N, ∀ n ≥ N, |1 / n - 0| < ε`\n"
"\n"
"## The Natural Language Proof Strategy\n"
"\n"
"Here's how we'll prove this step by step:\n"
"\n"
"**Step 1**: Let `ε > 0` be given. (This will correspond to `intro ε hε`)\n"
"\n"
"**Step 2**: We need to find `N` such that for all `n ≥ N`, we have `1 / n < ε`.\n"
"\n"
"**Key insight**: We need `1 / n < ε`, which is equivalent to `1 / ε < n` (since both sides are positive). So we need `n` to be larger than `1 / ε`.\n"
"When our Engineer requests the tolerance of `ε = 1/100`, the Machinist replies, ok, I can do that, but I'll need `N = 1 / ε = 100` days in my factory.\n"
"\n"
"\n"
"**Step 3**: That's exactly why we developed the Archimedean Property! It tells us that there exists some natural number `N` such that `1 / ε < N`.\n"
"Rather than reproving that from scratch, we can simply quote this fact;\n"
"then\n"
"we'll choose such an `N` and use it.\n"
"\n"
"**Step 4**: Now let `n ≥ N` be given. We have:\n"
"- `1 / ε < N` (by our choice of `N`)\n"
"- `N ≤ n` (by assumption)\n"
"- Therefore: `1 / ε < N ≤ n`, so `1 / ε < n`\n"
"- Taking reciprocals (and flipping the inequality): `1 / n < ε`\n"
"\n"
"**Step 5**: Since `|1 / n - 0| = |1 / n| = 1 / n < ε`, we're done! □\n"
"\n"
"## The Lean Implementation Challenges\n"
"\n"
"### Challenge 1: Cross-Multiplying Fractions\n"
"Our key step is showing that `1 / n < ε`. In paper mathematics, we'd simply cross-multiply to get `1 < n * ε`. But Lean is very careful about division by zero, so we can't just cross-multiply willy-nilly.\n"
"\n"
"**The Problem**: We want to go from `1 / n < ε` to `1 < n * ε`, but this is only valid if `n > 0` and `ε > 0`.\n"
"\n"
"**Solution**: The `field_simp` tactic handles this automatically! It will clear denominators by cross-multiplying, but only after it can verify that all denominators are positive (or at least non-zero).\n"
"\n"
"### Challenge 2: Linear Arithmetic\n"
"Once we've cleared the fractions, we need to combine various inequalities like:\n"
"- `1 / ε < N` (from the Archimedean Property)\n"
"- `N ≤ n` (our assumption)\n"
"- `1 < n * ε` (our goal after clearing denominators)\n"
"\n"
"For some reason, the `bound` tactic doesn't always handle these linear combinations well, especially when they involve multiplication by variables.\n"
"\n"
"**Solution**: The `linarith` tactic is specifically designed for linear arithmetic. It can take a list of hypotheses and solve goals that follow from linear combinations of those hypotheses.\n"
"\n"
"### Challenge 3: Explicit Type Casting\n"
"Remember those mysterious up arrows `↑` from the last level? They're back! When we write `1 / n`, Lean sees this as `1 / ↑n` where `n` starts as a natural number but needs to be cast as a real number.\n"
"\n"
"Sometimes we have to be specific about what type of casting to use. The expression `1 / ↑n` could be ambiguous—are we casting to integers, rationals, reals, or something else?\n"
"\n"
"**Solution**: Instead of an up arrow, we can specify the casting explicitly with this syntax: `(n : ℝ)`. This tells Lean exactly what type we want to cast `n` to, in this case, the reals. This eliminates ambiguity and makes your proofs more precise.\n"
"\n"
"### Challenge 4: Casting in Tactic Applications\n"
"Sometimes you want to apply a tactic or theorem, but the types don't quite match because of casting issues. For example, you might have the hypothesis that `N ≤ n` where `n, N` are naturals, but `bound` or `linarith` are searching for a proof that `(N : ℝ) ≤ (n : ℝ)` as reals.\n"
"\n"
"**Solution**: The `exact_mod_cast` tactic is like `apply`, but it automatically handles the type coercions for you. If you're trying to prove `(N : ℝ) ≤ (n : ℝ)`, and you have the hypothesis `h : N ≤ n` (as naturals), then you can write: `exact_mod_cast h`. Lean will look at `h`\n"
"and realize, oh it's exactly what you're trying to prove, but just\n"
"cast to a different number system; and it'll figure out the proof from there.\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"- **`field_simp`**: Clears denominators by cross-multiplying, but only when it can prove the denominators are non-zero. This is the key to handling fractional inequalities safely.\n"
"\n"
"- **Arithmetic with inequalities**: You might also find the `linarith` tactic helpful. It is a very powerful, general tactic like `ring_nf`, but instead of proving algebraic *identities*, it proves *inequalities* involving \"linear arithmetic\" on the specified hypotheses. For example,\n"
"if you have as hypotheses: `h₁ : X ≤ Y`, `h₂ : 2 * Y ≤ Z`,\n"
"and your Goal is to prove that `2 * X ≤ Z`, then\n"
"simply calling `linarith [h₁, h₂]` will do the trick. So add as many inequality hypotheses to your Game Board as you may need, and then call `linarith` on them to prove a Goal. I find that `linarith` is best called at the very end, when you've assembled all your facts and are ready to close a Goal (but it has many other uses as well, as you'll see).\n"
"\n"
"- **Explicit casting `(n : ℝ)`**: Tells Lean exactly what type to use, eliminating ambiguity in expressions like `1 / n`. You only need to cast\n"
"once in any expression, and Lean will automatically cast everything else.\n"
"For example, you can say `(0 : ℝ) < N`, and Lean will figure out that\n"
"the `0` you mean is a real number, and so, to compare that with `N`,\n"
"the latter too must be cast to the reals.\n"
"\n"
"- **`exact_mod_cast`**: Automatically handles type coercions between different number types (ℕ, ℤ, ℚ, ℝ), when the Goal is *exactly*\n"
"what you're trying to prove, just needs to get coerced.\n"
"\n"
"\n"
"## Pro Tips for This Level\n"
"\n"
"1. **Use `change`** to convert `SeqLim a 0` to its definition\n"
"2. **Apply the Archimedean Property** to get the existence of an `N`\n"
"3. **Use `choose`** to extract the `N` from the existential statement\n"
"4. **Establish positivity first** before using `field_simp`\n"
"5. **Work step by step** - don't try to do everything at once!\n"
"\n"
"## What Makes This Non-Trivial?\n"
"\n"
"Unlike the constant sequence (which was essentially definitional), this proof requires:\n"
"- **The Archimedean Property** to find a suitable `N`\n"
"- **Careful type management** between `ℕ` and `ℝ`\n"
"- **Positivity arguments** to handle division\n"
"- **Inequality manipulation** to connect our bounds\n"
"\n"
"This is a perfect example of how even \"obvious\" mathematical facts require sophisticated machinery to prove rigorously!"
msgstr ""

#: Game.Levels.L11PsetIntro
msgid "# Problem Set 11\n"
"\n"
"(Lighter than usual; study for the quiz!)\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L7Levels.L04_ByCases
msgid "Prove `EventuallyGeHalfLimPos`, but without the assumption that `L ≠ 0`."
msgstr ""

#: Game.Levels.L12Levels.L00_SubseqIterate
msgid "## What You've Accomplished\n"
"\n"
"You've just proven a fundamental result about extracting monotonic behavior from non-monotonic sequences. By taking the orbit of any sequence that grows faster than the identity, you've shown that iteration naturally produces strictly increasing subsequences.\n"
"\n"
"## The Key Insight\n"
"\n"
"The power of this result lies in the orbit construction: even though `σ` might jump around chaotically, as long as it always moves forward (`n < σ n`), iterating it from any starting point creates a predictable, monotonic pattern. This is the mathematical analogue of how planetary orbits reveal underlying order in seemingly complex celestial mechanics.\n"
"\n"
"## Looking Ahead\n"
"\n"
"This technique will be crucial in future levels. The ability to extract monotonic subsequences from sequences with persistent gaps will allow us to construct a contradiction with boundedness - showing that such gaps must eventually disappear.\n"
"\n"
"The orbit method you've mastered here demonstrates a powerful principle: iteration can transform local properties (like `n < σ n`) into global structure (like strict monotonicity). This pattern appears throughout analysis, where local behavior accumulates into global phenomena."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "First Real Limit"
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
#: Game.Levels.L1Pset.L1Pset3
#: Game.Levels.L1Pset.L1Pset4
#: Game.Levels.L1Pset.L1Pset5
#: Game.Levels.L2Pset.L2Pset1
#: Game.Levels.L2Pset.L2Pset2
#: Game.Levels.L3Pset.L3Pset1
#: Game.Levels.L3Pset.L3Pset2
#: Game.Levels.L3Pset.L3Pset3
#: Game.Levels.L3Pset.L3Pset4
#: Game.Levels.L4Pset.L4Pset1
#: Game.Levels.L6Pset.L6Pset1
#: Game.Levels.L6Pset.L6Pset2
#: Game.Levels.L6Pset.L6Pset3
#: Game.Levels.L6Pset.L6Pset4
#: Game.Levels.L7Pset.L7Pset1
#: Game.Levels.L7Pset.L7Pset2
#: Game.Levels.L7Pset.L7Pset3
#: Game.Levels.L10Pset.L10Pset2
#: Game.Levels.L10Pset.L10Pset3
#: Game.Levels.L10Pset.L10Pset4
#: Game.Levels.L10Pset.L10Pset5
#: Game.Levels.L10Pset.L10Pset6
#: Game.Levels.L10Pset.L10Pset7
#: Game.Levels.L11Pset.L11Pset1
msgid "Done."
msgstr ""

#: Game.Levels.L9Levels.L04_FiniteSums
msgid "# 🎉 Excellent Work!\n"
"\n"
"You've just proven a fundamental result about finite sums! This theorem might seem simple, but it's a powerful building block that appears throughout analysis.\n"
"\n"
"## What You Accomplished\n"
"\n"
"You successfully proved that **every term is bounded by the total sum**:\n"
"```\n"
"∀ n < N, |a n| ≤ ∑ k ∈ range N, |a k|\n"
"```\n"
"\n"
"### Key Techniques You Mastered:\n"
"\n"
"1. **Strategic induction** - You learned to use induction on `N` *before* introducing the universal quantifier, which made the proof structure much cleaner\n"
"\n"
"2. **Working with finite sums** - You used `sum_range_succ` to peel off terms and `sum_nonneg` to establish nonnegativity\n"
"\n"
"3. **Case analysis** - You split the proof into two cases (`n < N` vs `n = N`) and handled each appropriately\n"
"\n"
"4. **Combining results** - You cleverly used the inductive hypothesis for earlier terms and nonnegativity for the final term\n"
"\n"
"## Why This Matters\n"
"\n"
"This result is essential for the next level! You'll use `TermLeSum` to prove that **convergent sequences are bounded**. Here's the connection:\n"
"\n"
"- Every convergent sequence is eventually close to its limit\n"
"- But what about the finitely many terms *before* it gets close?\n"
"- That's where your theorem comes in! You can bound those initial terms by their finite sum\n"
"- Combine this with the eventual bound, and you get a global bound for the entire sequence\n"
"\n"
"## Looking Ahead\n"
"\n"
"In the next level, you'll prove `BddOfConvNonzero`: convergent sequences with nonzero limits are bounded. This is a cornerstone result in analysis that tells us convergent sequences can't escape to infinity.\n"
"\n"
"Ready to see your theorem in action? Let's move on!"
msgstr ""

#: Game.Levels.L13Levels.L03_MonotoneSubseq
msgid "If you have a proposition `P`, you can say `if P then x else y`."
msgstr ""

#: Game.Levels.L6Pset.L6Pset5
msgid "# Problem 5\n"
"\n"
"You are given five sequences `a b c d e : ℕ → ℝ`, and you know that\n"
"`a`, `c`, and `e` converge to `L`, and that, for all `n`, `a n ≤ b n ≤ c n ≤ d n ≤ e n`.\n"
"Prove that both `b` and `d` also converge to `L`."
msgstr ""

#: Game.Levels.L10Levels.L07_Order
msgid "`(a : ℕ → ℝ) (M : ℝ) := ∀ n, a n ≤ M`\n"
"\n"
"A sequence `a : N → ℝ` is *bounded by* (`SeqBddBy` holds) `M : ℝ` if, for all `n`, `a n ≤ M`, for all `n`."
msgstr ""

#: Game.Levels.L12Levels.L02_IterateGap
msgid "Iterated Gaps"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "If a function of `x` always equals `x²`, then it equals `t²` when evaluated at `t`."
msgstr ""

#: Game.Levels.L7Pset.L7Pset3
msgid "# Problem 3\n"
"\n"
"Prove `abs_Lipschitz`, obviously without referring to that theorem!\n"
"(Hint: you'll want to break things into cases according to whether `0 ≤ x` or not,\n"
"then systematically use `abs_of_nonneg` and `abs_neg`...)"
msgstr ""

#: Game.Levels.L3Pset.L3Pset4
msgid "# Problem 4\n"
"\n"
"Here's an even more involved limit problem. We've had luck getting `bound` to prove `|X| = X`, especially when there's a hypothesis `h : 0 ≤ X` already available in the list of assumptions. But I've found it not to be reliable, unfortunately. So let me give you one more theorem for your toolchest.\n"
"\n"
"## New Theorem: `abs_of_nonneg`.\n"
"If you have a hypothesis `h : 0 ≤ X` in your toolchest,\n"
"then you can prove that `|X| = X` via:\n"
"\n"
"`have factName : |X| = X := by apply abs_of_nonneg h`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "The `ring_nf` tactic puts both sides of an equation into a standard algebraic form and checks if they're equal."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "Use `intro ε` to introduce the variable, then `intro hε` to introduce the hypothesis `ε > 0`. Then how do you solve the goal?"
msgstr ""

#: Game.Levels.L6Levels.L00_SumOfSeqs
msgid "Big Boss: The Sum of Convergent Sequences"
msgstr ""

#: Game.Levels.L6Levels.L02_LeftRight
msgid "# 🎯 Strategic Decision-Making Mastered! 🎯\n"
"\n"
"Excellent! You've now learned how to navigate the fundamental logical choice points in mathematical proof. The `left` and `right` tactics represent one of the most elegant aspects of mathematical reasoning: sometimes proving less is actually more efficient.\n"
"\n"
"**Why This Matters:**\n"
"\"Or\" statements are everywhere in mathematics. Existence proofs often have this flavor -- \"there exists an `x` such that `P(x)` or `Q(x)`\" -— and being able to choose the right branch can dramatically simplify your proof strategy.\n"
"\n"
"**The Art of Mathematical Choice:**\n"
"Notice how in our example, we had information about both `x` and `y`, but we chose to go `right` and use the fact about `y`. This wasn't arbitrary -- it was the path that led directly to our goal. Learning to recognize these opportunities is a key skill in mathematical reasoning.\n"
"\n"
"**Looking Forward:**\n"
"As we continue developing our proof techniques for analysis, you'll find that `left` and `right` combine powerfully with our convergence arguments. Often we'll need to prove statements like \"either the sequence is eventually positive, or it's eventually negative,\" and these tactics will be essential tools in our arsenal.\n"
"\n"
"Mathematics is as much about knowing when to commit to a path as it is about following that path to its conclusion. You're building the judgment to make these strategic choices wisely."
msgstr ""

#: Game.Levels.L6Lecture
msgid "Lecture 6: Algebraic Limit Theorem, Part II"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L04_ring_nf
msgid "The ring_nf tactic"
msgstr ""

#: Game.Levels.L4Pset.L4Pset1
msgid "# Problem 1\n"
"\n"
"Let `a (n)` be a sequence that alternates between\n"
"`3 - 1 / n` and `1 + 1 / n`. Prove that this sequence diverges.\n"
"\n"
"**Hint:** You may wish to argue using `N` that's slightly\n"
"larger than the smallest possible value.\n"
"\n"
"**Hint 2:** If your desired `have` is a consequence of two facts put together, you can separate them by a semicolon. For example, if you know that `h : X = Y + Z`,\n"
"and you want to add a hypothesis `h' : |X - Y| = |Z|`, which is a combination of rewriting by `h` and a ring operation, then you can say:\n"
"\n"
"`have h' : |X - Y| = |Z| := by rewrite [h]; ring_nf`.\n"
"\n"
"This might come in handy!..."
msgstr ""

#: Game.Levels.L12Pset.L12Pset1
#: Game.Levels.L12Pset.L12Pset1
msgid "If `a` is `Antitone`, then `-a` is `Monotone`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L03_rw
msgid "If we know that $x = 2$, then we can prove that $x + y = 2 + y$."
msgstr ""

#: Game.Levels.L9PsetIntro
msgid "Pset 9"
msgstr ""

#: Game.Levels.L12Levels.L01_MonotoneBdd
msgid "`(a : X → Y) {i j} (hij : i ≤ j) : a i ≤ a j`\n"
"\n"
"A sequence `a : X → Y` is said to be `Monotone` if `a n ≤ a m` whenever `n ≤ m`."
msgstr ""

#: Game.Levels.L6Levels.L05_AbsLt
msgid "# Level 6: AbsLe - Working with Absolute Values in Convergence\n"
"\n"
"Now that you've mastered the complete And/Or toolkit, it's time to apply these skills to a fundamental aspect of real analysis: working with absolute values in the context of sequence convergence. This level introduces you to one of the most useful tools for manipulating absolute value inequalities.\n"
"\n"
"You now have the full And/Or matrix \"Cheat Sheet\":\n"
"\n"
"|           | ∧        | ∨      |\n"
"|-----------|----------|--------|\n"
"| **Goal**  | `split_ands`    | `left`/`right`  |\n"
"| **Hypothesis** | `h.1`, `h.2` | `cases'` |\n"
"\n"
"Remember our definition of sequence convergence: `SeqLim a L` means that for any `ε > 0`, there exists an `N` such that for all `n ≥ N`, we have `|a n - L| < ε`. The absolute value here captures the idea that the sequence terms can approach the limit from either direction—they might be slightly above L or slightly below L, but either way, they're getting close.\n"
"\n"
"However, sometimes we need to extract more specific information from this absolute value condition. We might need to know that the sequence terms are not just close to L, but specifically that they're bounded below by `L - ε` or bounded above by `L + ε`. This is where the `abs_lt` theorem becomes invaluable.\n"
"\n"
"The key insight is that `|x| < y` is equivalent to saying both `-y < x` AND `x < y`. This gives us a way to \"unpack\" absolute value statements into more manageable pieces that we can work with using our And/Or toolkit.\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"**`abs_lt`**: This theorem states that `|x| < y` if and only if `-y < x ∧ x < y`. This allows you to convert between absolute value inequalities and conjunction of regular inequalities, making them easier to work with in proofs."
msgstr ""

#: Game.Levels.L12Levels.L01_MonotoneBdd
#: Game.Levels.L14Levels.L01_BolzanoWeierstrass
msgid "If a sequence `a : ℕ → X` (where `X` could be `ℚ` or `ℝ`) is `Monotone` and grows along some subsequences by `ε`, then it eventually grows by `k * ε` for any `k`."
msgstr ""

#: Game.Levels.L6Levels.L04_Cases'
msgid "# Level 5: Cases' - Handling All Possibilities\n"
"\n"
"You've now mastered creating \"or\" statements with `left` and `right`, but what happens when you're given an \"or\" statement as a hypothesis and need to work with it? This is where the `cases'` tactic becomes essential—it's the perfect complement to the choice-making tactics you've already learned.\n"
"\n"
"When you have a hypothesis like `h : P ∨ Q`, you know that either `P` is true or `Q` is true, but you don't know which one. To proceed with your proof, you need to consider both possibilities systematically. The `cases'` tactic does exactly this: it splits your proof into two separate cases, one for each possibility.\n"
"\n"
"Think of this like a lawyer preparing for trial. If you know \"either the defendant was at home OR the defendant was at work\" during the time of the incident, you need to prepare your argument for both scenarios. You can't just pick one and hope for the best—you need a strategy that works regardless of which turns out to be true.\n"
"\n"
"In mathematical analysis, this pattern appears constantly. You might know that a sequence is either eventually positive or eventually negative, and need to prove something that holds in both cases. Or you might know that a function achieves its maximum either in the interior of an interval or at one of the endpoints.\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"**`cases'`**: When you have a hypothesis `h : P ∨ Q`, you can say `cases' h with h1 h2`. This creates two separate goals:\n"
"- In the first goal, you get a new hypothesis `h1 : P`\n"
"- In the second goal, you get a new hypothesis `h2 : Q`\n"
"\n"
"You must solve both goals to complete your proof. This ensures you've covered all logical possibilities."
msgstr ""

#: Game.Levels.L7Pset.L7Pset1
msgid "# Problem 1\n"
"\n"
"Suppose that a sequence `a : ℕ → ℝ` converges to `L ≠ 0`. Show that eventually `|a n|` is at most\n"
"`2|L|`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L02_rfl
msgid "Excellent! You've learned the `rfl` tactic.\n"
"\n"
"The key difference:\n"
"- Use `apply hypothesis_name` when you have a hypothesis that matches your goal\n"
"- Use `rfl` when you need to prove that something equals itself\n"
"\n"
"These are two of the most fundamental tactics in Lean. As we progress through real analysis, you'll see that many complex proofs ultimately come down to showing that two expressions are identical."
msgstr ""

#: Game.Levels.L6Levels.L06_Squeeze
msgid "# Level 7 Big Boss: Squeeze Theorem\n"
"\n"
"Welcome to another Big Boss level! You're about to prove one of the most elegant and powerful theorems in real analysis: the Squeeze Theorem (also known as the Sandwich Theorem or Pinching Theorem). This theorem beautifully captures the intuitive idea that if you trap a sequence between two other sequences that both converge to the same limit, then the trapped sequence must also converge to that limit.\n"
"\n"
"The Squeeze Theorem is a perfect showcase for how the logical tools you've been developing—working with conjunctions, absolute values, and inequalities—come together to prove deep mathematical results. You'll need to orchestrate all your skills: extracting information from convergence conditions, managing multiple epsilon-N arguments simultaneously, and combining inequalities with absolute value manipulations.\n"
"\n"
"**The Intuitive Picture:**\n"
"Imagine three runners on a track. Runner A and Runner C are both heading to the same finish line L, and Runner B is always between them. No matter how A and C weave back and forth, as long as they both end up at L and B stays between them, B must also end up at L. There's simply nowhere else for B to go!\n"
"\n"
"**The Mathematical Challenge:**\n"
"The formal proof requires careful epsilon management. Given any tolerance `ε`, you need to show that `b (n)` gets within `ε` of `L`. Since `a (n)` and `c (n)` both get within `ε` of `L`, and `b (n)` is squeezed between them, you can use the transitivity of inequalities to show that `b (n)` is also within `ε` of `L`."
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "Also try unfolding the definition in `h`: `change ∀ ε₁ > 0, ∃ N₁ : ℕ, ∀ n ≥ N₁, |a n - L| < ε₁ at h`"
msgstr ""

#: Game.Levels.L11Lecture
msgid "Lecture 11: The Real Numbers I"
msgstr ""

#: Game.Levels.L9Pset.L9Pset2
msgid "# Problem 2\n"
"\n"
"Prove that `N * (N + 1)` is always even."
msgstr ""

#: Game.Levels.L9Levels.L04_FiniteSums
msgid "# Level 1: Finite Sums\n"
"\n"
"Welcome to a new world of mathematics: **finite sums**! In this level, you'll prove that any individual term in a sum of absolute values is bounded by the total sum. This is a fundamental property that bridges discrete and continuous mathematics.\n"
"\n"
"## The Goal\n"
"\n"
"Prove that for any sequence `a : ℕ → ℝ` and natural number `N`, every term `|a n|` with `n < N` is at most the sum `∑ k ∈ range N, |a k|`.\n"
"\n"
"Intuitively: if you're adding up a bunch of nonnegative numbers, no single number can be bigger than the total!\n"
"\n"
"## Strategy: Induction from the Start!\n"
"\n"
"🎯 **Big Hint:** Even though the goal starts with `∀ n < N`, do **NOT** begin with `intro n hn`. Instead, run **induction on `N`** right from the beginning!\n"
"\n"
"This might feel counterintuitive, but trust the process. Induction gives you the perfect structure to peel off one term at a time using `sum_range_succ`.\n"
"\n"
"### Your Induction Strategy:\n"
"- **Base case (`N = 0`):** There are no natural numbers less than 0, so you'll get a `contradiction`\n"
"- **Inductive step (`N → N + 1`):** Use `sum_range_succ` to write the sum for `N + 1` as the sum for `N` plus the new term `|a N|`\n"
"  - Split into cases: Is `n < N` (use inductive hypothesis) or `n = N` (use nonnegativity)?\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"### Summation Notation\n"
"`∑ k ∈ range N` means sum as `k` goes from `0` to `N - 1` (which has `N` terms total!)\n"
"\n"
"### `sum_range_succ`\n"
"Peels off the last term: `∑ k ∈ range (N + 1), f k = (∑ k ∈ range N, f k) + f N`\n"
"\n"
"### `sum_nonneg`\n"
"If each term is nonnegative, so is the sum. Usage: `apply sum_nonneg`, then prove `∀ k ∈ range N, 0 ≤ f k`\n"
"\n"
"### `contradiction`\n"
"If your hypotheses are contradictory (like `n : ℕ` with `n < 0`), this tactic closes the goal immediately.\n"
"\n"
"### `by_cases`\n"
"Split into cases based on a decidable proposition. Usage: `by_cases h : n < N` creates two goals:\n"
"- One where `h : n < N` holds\n"
"- One where `h : ¬(n < N)` holds\n"
"\n"
"Good luck! Remember: **induction first, then introduce `n`!**"
msgstr ""

#: Game.Levels.L8Pset.L8Pset1
#: Game.Levels.L8Pset.L8Pset2
#: Game.Levels.L8Pset.L8Pset3
#: Game.Levels.L8Pset.L8Pset4
#: Game.Levels.L9Pset.L9Pset1
#: Game.Levels.L9Pset.L9Pset2
#: Game.Levels.L9Pset.L9Pset3
#: Game.Levels.L12Pset.L12Pset1
#: Game.Levels.L12Pset.L12Pset2
#: Game.Levels.L13Levels.L03_MonotoneSubseq
#: Game.Levels.L13Pset.L13Pset1
#: Game.Levels.L14Levels.L01_BolzanoWeierstrass
msgid ""
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "This is a good time to record the fact that `1 / ε ≤ ⌈1 / ε⌉₊`.\n"
"You can do that with: `have fact : 1 / ε ≤ ⌈1 / ε⌉₊ := by bound`. The `bound` tactic can solve inequalities like this."
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "You might think that the `bound` tactic\n"
"would also be able to solve `1 / ε < ↑(⌈1 / ε⌉₊ + 1)`, but No!\n"
"That's because the addition `⌈1 / ε⌉₊ + 1` happens as **natural numbers**, and only then is the result cast to the reals; so the\n"
"`fact` that was just proved is not useful to `bound`. Instead try: `push_cast` to get the casting to push down as far as possible.\n"
"The Goal will change to `1 / ε < ↑⌈1 / ε⌉₊ + 1`, where now the\n"
"ceiling is cast to the reals, and then the real number `1` is added."
msgstr ""

#: Game.Levels.L6Levels.L05_AbsLt
msgid "This says that `|x| < y` if and only if `-y < x ∧ x < y`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "# 🎉 VICTORY! 🎉\n"
"\n"
"You've defeated the Big Boss and mastered all the fundamental tactics of mathematical reasoning!\n"
"\n"
"**Let's see what you just accomplished:**\n"
"\n"
"1. **`choose a ha using h_existential`** - Extracted the witness `a` and fact that `f (a) = 3` from the hypothesis\n"
"2. **`use a`** - Chose `a` as your witness for the existence statement in the goal\n"
"3. **`intro y hy`** - Handled the universal quantifier \"for all y > 0\" in the goal\n"
"4. **`specialize h_universal y hy`** - Applied the universal property to your specific value in the hypothesis\n"
"5. **`rewrite [h_universal]`** - Used the specialized fact to rewrite the goal\n"
"6. **`rewrite [ha]`** - Used the original fact that `f (a) = 3` to also rewrite the goal\n"
"7. **`ring_nf`** - Verified finally that `(f y + 9) ^ 2 = (f y + 3 ^ 2) ^ 2`\n"
"\n"
"You've just completed a genuinely sophisticated mathematical argument! This kind of multi-step reasoning, combining existence statements, universal properties, and algebraic manipulation, is exactly what you'll encounter throughout real analysis.\n"
"\n"
"**You are now ready to begin your journey to rigorous calculus!**\n"
"\n"
"Welcome to the Introduction to Formal Real Analysis. 🎓\n"
"\n"
"**Epilogue**\n"
"\n"
"Before we continue with more Real Analysis and more Lean, let’s pause to note a few interesting things about working formally.\n"
"Using a theorem prover interactively is (I hope) tremendously fun and (I hope) leads to rapid gains, immediate feedback, and clarity of thought.\n"
"\n"
"Imagine trying to learn chess by just reading through algebraic notation - 1.e4 e5 2.Nf3 Nf6 3.Bb5 a6 - sure, all the information is technically there, but isn't it so much easier to learn by actually looking at a chess board and seeing how the position changes after each move? In mathematics, it would be extraordinarily tedious to manually write on the blackboard the entire goal state after every move, keeping track of all the hypotheses and their relationships by hand. A theorem prover does this bookkeeping for you automatically, letting you focus on the mathematical content rather than the clerical work.\n"
"\n"
"But! This is, as we've already noted, a double-edged sword. We still want to train our brains to \"see\" a mental model of the goal state evolving - good chess players can visualize many moves ahead precisely because they've learned to maintain multiple mental game boards simultaneously. But until you develop that skill, and even after you have it, there's immense value in being able to instantly generate the current \"game board\" of your proof state. The immediate feedback helps you understand the consequences of each logical move, building the very intuition that will eventually let you work more independently. It's the difference between learning to navigate by always checking your GPS versus eventually developing an internal sense of direction - both have their place, and the former helps develop the latter."
msgstr ""

#: Game.Levels.L4Lecture
msgid "Lecture 4: Even more fun with Sequences"
msgstr ""

#: Game.Levels.L13Levels.L03_MonotoneSubseq
msgid "`(a : ℕ → X) (n : ℕ) := ∀ m > n, a m ≤ a n`\n"
"\n"
"For a sequence `a : ℕ → X` (where `X` is `ℚ` or `ℝ`) and `n : ℕ`, we say that `IsAPeak a n` if: `∀ m > n, a m ≤ a n`."
msgstr ""

#: Game.Levels.L6Levels.L00_SumOfSeqs
msgid "# Level 1 **Big Boss**: Adding Convergent Sequences\n"
"\n"
"Now that we've had some experience with the definition of convergence, let's tackle this world's Big Boss. One of the most fundamental ideas in analysis is that 'nice operations preserve convergence.' If two sequences each converge, then their sum also converges, and converges to the sum of their limits.\n"
"\n"
"This might seem obvious at first -- after all, if $a(n)$ is getting close to $L$ and $b(n)$ is getting close to $M$, shouldn't $a(n) + b(n)$ get close to $L + M$? While the intuition is correct, making this rigorous requires some clever maneuvering with our epsilon-N definition.\n"
"\n"
"**Big Boss**\n"
"Here's the key insight: if an engineer demands that our combined output be within $\\varepsilon$ of the target $L + M$, we can't just demand that each factory independently meet the full tolerance $\\varepsilon$. Instead, we need to be clever about how we allocate our 'tolerance budget.'\n"
"\n"
"Think of it this way: if the first factory can guarantee its output is within $\\varepsilon/2$ of $L$, and the second factory can guarantee its output is within $\\varepsilon/2$ of $M$, then by the triangle inequality, their sum will be within $\\varepsilon$ of $L + M$. This is the heart of the proof!\n"
"\n"
"## The Mathematical Setup\n"
"\n"
"Suppose we have:\n"
"- A sequence $a : \\mathbb{N} \\to \\mathbb{R}$ that converges to $L$\n"
"- A sequence $b : \\mathbb{N} \\to \\mathbb{R}$ that converges to $M$\n"
"- A sequence $c : \\mathbb{N} \\to \\mathbb{R}$ with the property that $c(n) = a(n) + b(n)$ for all $n$\n"
"\n"
"We want to prove that $c$ converges to $L + M$.\n"
"\n"
"\n"
"## Your Strategic Approach\n"
"\n"
"- Start by unfolding the definitions of `SeqLim` in the Goal and hypotheses. I recommend you give your dummy variables different names, so as not to get confused later.\n"
"- Given any `ε > 0`, use the convergence of `a` to get an `Na` that works for `ε / 2`.\n"
"- Similarly, use the convergence of `b` to get an `Nb` that works for `ε / 2`\n"
"- You might think that it would be a good idea at this point to `use max Na Nb`, that is, take the larger of the two for `N`. But we don't care how big `N` is! Can you\n"
"think of another way to achieve the same objective? (Hint:\n"
" I haven't told you how to use the `max` function, but I bet you can come up with another function for which you already have everything you need at your disposal...)\n"
"- Use the triangle inequality to combine the two half-tolerances\n"
"\n"
"This proof embodies a fundamental principle in analysis: when dealing with sums, we often need to 'divide and conquer' by splitting our error tolerance between the components."
msgstr ""

#: Game.Levels.L7Levels.L02_SeqOfAbs
msgid "# Level 3: Continuity of Absolute Value—Sequences of Absolute Values\n"
"\n"
"The absolute value function behaves extremely well with respect to limits—if a sequence\n"
"converges, then the sequence of absolute values converges to the absolute value of the\n"
"limit. This is a manifestation of the **continuity** of the absolute value function.\n"
"\n"
"\n"
"## What We're Proving\n"
"\n"
"**Theorem:** If `a : ℕ → ℝ` converges to `L`, and `b : ℕ → ℝ` is defined by\n"
"`b n = |a n|` for all `n`, then `b` converges to `|L|`.\n"
"\n"
"In other words: taking absolute values preserves convergence.\n"
"\n"
"## New Tool: `abs_Lipschitz`\n"
"\n"
"A function `f : ℝ → ℝ` is called \"Lipschitz\"  (with constant `K`) if we have `|f(x) - f(y)| ≤ K · |x - y|` for all `x` and `y`. This means the function can't change too rapidly—the output values can't get farther apart than `K` times the input distance.  The theorem `abs_Lipschitz`  states that for any real numbers `x` and `y`:\n"
"$$||x| - |y|| \\leq |x - y|$$\n"
"that is, the absolute value function is Lipschitz with constant `K = 1`. This means taking absolute values is non-expansive: it never increases distances between points, and often decreases them.\n"
"\n"
"(This is also sometimes called the **reverse triangle inequality for absolute values**.)\n"
"\n"
"The proof of this fact will be reserved for the Exercises.\n"
"\n"
"## The Strategy\n"
"\n"
"This proof is remarkably clean compared to our previous results:\n"
"\n"
"1. Given `ε > 0`, use convergence of `a` to get `N` such that `|a n - L| < ε` for `n ≥ N`\n"
"2. For `n ≥ N`, observe that `b n = |a n|`\n"
"3. Apply `abs_Lipschitz`: `||a n| - |L|| ≤ |a n - L| < ε`\n"
"4. Therefore `|b n - |L|| < ε`, proving `b n → |L|`\n"
"\n"
"The Lipschitz property does all the heavy lifting for us!\n"
"\n"
"## Why This Matters\n"
"\n"
"This theorem is a special case of a much more general principle: **continuous functions\n"
"preserve limits**. The absolute value function is continuous everywhere, so it maps\n"
"convergent sequences to convergent sequences. This principle extends to all continuous\n"
"functions and is fundamental to mathematical analysis."
msgstr ""

#: Game.Levels.L2PsetIntro
msgid "# Problem Set 2\n"
"\n"
"This is problem set 2."
msgstr ""

#: Game.Levels.L11Levels.L01_IsCauchyOfLim
msgid "# Level 1: Big Boss - Limits are Cauchy\n"
"\n"
"Now that we understand what a Cauchy sequence is, let's prove our first major theorem: **every convergent sequence is Cauchy**.\n"
"\n"
"This might seem obvious at first—if a sequence converges to some limit `L`, then the terms should eventually be close to each other. But making this intuition rigorous requires careful epsilon management!\n"
"\n"
"## The Key Insight\n"
"\n"
"If `aₙ → L`, then for large `n` and `m`, both `aₙ` and `aₘ` are close to `L`. By the triangle inequality, this means they must be close to *each other*:\n"
"\n"
"`|aₙ - aₘ| = |(aₙ - L) + (L - aₘ)| ≤ |aₙ - L| + |L - aₘ|`\n"
"\n"
"## Strategy\n"
"\n"
"1. **Extract the limit**: Since the sequence converges, use `choose` to get the limit `L`\n"
"2. **Clever epsilon choice**: Apply the definition of `aₙ → L` with `ε/2` (not `ε`!)\n"
"3. **Rewrite the goal**: Express `|aₙ - aₘ|` in terms of differences from `L`\n"
"4. **Apply triangle inequality**: Split the absolute value of a sum\n"
"5. **Use symmetry**: Apply `abs_sub_comm` to get `|L - aₘ| = |aₘ - L|`\n"
"6. **Finish with arithmetic**: Both pieces are less than `ε/2`, so the sum is less than `ε`\n"
"\n"
"## New Definition\n"
"\n"
"**`IsCauchy a`**: A sequence `a : ℕ → ℝ` is Cauchy if\n"
"`∀ ε > 0, ∃ N, ∀ n ≥ N, ∀ m ≥ n, |a m - a n| < ε`\n"
"\n"
"## New Theorem\n"
"\n"
"**`abs_sub_comm`**: `|x - y| = |y - x|`\n"
"(Subtraction is commutative inside absolute values)\n"
"\n"
"This is your first Big Boss level working with the Cauchy definition. Take your time, and remember: when in doubt, divide epsilon by 2!"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "The intro tactic"
msgstr ""

#: Game.Levels.L10Levels.L08_Mono
msgid "`(σ : ℕ → ℕ) := ∀ i j, i < j → σ i < σ j`\n"
"\n"
"A sequence `σ : ℕ → ℕ` is a *subsequence* if `∀ i j, i < j → σ (i) < σ (j)`."
msgstr ""

#: Game.Levels.L3Pset.L3Pset2
msgid "# Problem 2\n"
"\n"
"Prove that the sequence `(n + 1) / n` has a limit, say, `L`, and determine what it is.\n"
"\n"
"We haven't yet learned a good way to use the theorem `OneOverNLimZero`\n"
"that we already proved, so just adapt the proof of that, rather than trying to quote it. (It's good practice!)"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "Great! You've learned the `specialize` tactic.\n"
"\n"
"Notice what happened:\n"
"1. Initially, `hf : ∀ x > 0, f (x) = x^2` was a universal statement\n"
"2. `specialize hf t` transformed it into `hf : t > 0 → f (t) = t ^ 2`\n"
"3. Another `specialize` command, namely `specialize hf t_pos` turned the\n"
"hypothesis `hf` into `hf : f (t) = t ^ 2`\n"
"4. And finally, `apply hf` worked because the hypothesis matched the goal.\n"
"\n"
"The pattern is:\n"
"- `intro` when you have `∀` in the goal (\"introduce an arbitrary term...\")\n"
"- `specialize` when you have `∀` in a hypothesis (\"apply the hypothesis to specific value...\")\n"
"\n"
"This is fundamental in real analysis when working with:\n"
"- Function properties that hold \"for all x\"\n"
"- Limit definitions involving \"for all ε > 0\"\n"
"- Continuity statements\n"
"\n"
"Last lesson in Lecture 1 coming up."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "Excellent! You've learned the `intro` tactic for universal statements.\n"
"\n"
"Notice what happened:\n"
"1. `intro ε` introduced the arbitrary real number ε\n"
"2. `intro hε` introduced the hypothesis `hε : ε > 0`\n"
"3. The goal became `(ε + 1)^2 = (ε + 1)^2`\n"
"4. `rfl` solved the goal, by the reflexive property of the equals sign.\n"
"\n"
"You might have noticed something interesting: we used `intro` in two seemingly different ways -- first to introduce an \"Object\" (the real number `ε`), and second to introduce an \"Assumption\" or hypothesis (that `ε > 0`). In Lean's underlying logic (\"dependent type theory\"), there's actually a deep unity here that mathematicians call the *Curry-Howard correspondence*: propositions are \"Types\", and proofs are \"Terms\" of those Types. This means that introducing a hypothesis is really just introducing a term of a certain type, just like introducing a variable.\n"
"\n"
"But here's an even more mind-bending perspective: our entire Statement is really a *function*! Its inputs are first an `ε : ℝ`, then a proof that `ε > 0`, and its output is a proof that `(ε + 1)^2 = (ε + 1)^2`. When we write `intro ε` and `intro h`, we're literally defining this function by saying \"given these inputs, here's how to compute the output.\" In this view, all of mathematics -- from the simplest definitions to proofs of the deepest theorems -- is secretly just **functions** transforming inputs into outputs!\n"
"\n"
"This beautiful connection between logic and computation underlies much of modern proof assistants, though we won't dive into the details in this course -- it's perfectly fine if you didn't follow the last two paragraphs! For now, just appreciate that `intro` works uniformly whether you're introducing mathematical objects or logical assumptions, and that every proof you write is secretly a program!\n"
"\n"
"The `intro` tactic is absolutely crucial in real analysis. You'll use it constantly to:\n"
"- Handle \"for all ε > 0\" statements in limit definitions\n"
"- Introduce arbitrary points in domain/range proofs\n"
"- Work with function definitions\n"
"\n"
"This pattern of `intro` followed by algebraic manipulation is everywhere in analysis!"
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "Start by unfolding the definition: `change ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, |b n - 2 * L| < ε`"
msgstr ""

#: Game.Levels.L13Pset.L13Pset1
msgid "If `a (n+1) ≤ a n` holds for all `n`, then `a` is `Monotone`."
msgstr ""

#: Game.Levels.L11Pset.L11Pset1
msgid "# Problem 1:\n"
"\n"
"Prove that the sequence `a n = n` has no convergent subsequence."
msgstr ""

#: Game.Levels.L10PsetIntro
msgid "# Problem Set 10\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L1Pset.L1Pset3
#: Game.Levels.L3Pset.L3Pset3
#: Game.Levels.L6Pset.L6Pset3
#: Game.Levels.L7Pset.L7Pset3
#: Game.Levels.L8Pset.L8Pset3
#: Game.Levels.L9Pset.L9Pset3
#: Game.Levels.L10Pset.L10Pset4
msgid "Problem 3"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "Prove that the constant sequence converges to its constant value.\n"
"This is the Machinist's dream scenario: we're already producing exactly what's required!"
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "For any real numbers `x` and `y`, we have `|x * y| = |x| * |y|`."
msgstr ""

#: Game.Levels.L11Levels.L01_IsCauchyOfLim
msgid "Usage: `have factName : |x - y| = |y - x| := by apply abs_sub_comm`"
msgstr ""

#: Game.Levels.L9Pset.L9Pset1
msgid "# Problem 1\n"
"\n"
"Prove the same theorem as `BddOfConvNonzero`, but without the assumption that `L ≠ 0`. (Hint: break\n"
"the proof into cases, and the case `L ≠ 0` should just be an appeal to `BddOfConvNonzero`. What\n"
"do you do in the other case?)"
msgstr ""

#: Game.Levels.L9Pset.L9Pset3
msgid "`1 + 2 + ... + N = N * (N + 1) / 2`."
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "The `push_cast` tactic handles coercions between number types, particularly useful when working with natural numbers that need to be treated as real numbers (or integers, or rationals)."
msgstr ""

#: Game.Levels.L6Levels.L02_LeftRight
msgid "# Level 3: Left and Right - Making Choices in Mathematics\n"
"\n"
"After mastering `split_ands` to handle situations where we need to prove multiple things simultaneously, we now turn to a fundamentally different scenario: proving that at least one of several possibilities is true. This is the world of \"or\" statements (`∨`), and it requires a completely different strategic approach.\n"
"\n"
"While `split_ands` was about being comprehensive—proving every part of a conjunction—proving an \"or\" statement (\"disjunction\") is about making a strategic choice. When faced with proving \"P or Q,\" you don't need to prove both `P` and `Q`. You just need to prove one of them! This might seem easier, but it requires good mathematical judgment: which path should you choose?\n"
"\n"
"Think of this like a detective solving a case. To prove \"the butler did it OR the gardener did it,\" you don't need to prove both are guilty -- you just need solid evidence against *one* of them. The `left` and `right` tactics are your way of saying \"I'm going to focus my investigation on this suspect.\"\n"
"\n"
"In mathematical analysis, this choice-making appears everywhere. For instance, when proving that a sequence is bounded, you might show either that it's bounded above by some constant, or bounded below by another constant, or both. Sometimes one direction is much easier to establish than the other.\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"- `left` and `right` tactics\n"
"\n"
"When your goal is to prove an \"Or\" statement, `P ∨ Q`, you can do that by proving either `P` or `Q`. If you want to prove `P`, then say `left`, and the Goal will turn into `P`.\n"
" If you want to prove `Q`, then say `right`, and the Goal will turn into `Q`."
msgstr ""

#: Game.Levels.L3PsetIntro
msgid "Pset 3"
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "Step 3:\n"
"Once more, in natural language.\n"
"\n"
"\n"
"## Natural Language Proof\n"
"\n"
"**Theorem:** The sequence `1`, `-1`, `1`, `-1`, ... does not converge.\n"
"\n"
"**Proof by contradiction:**\n"
"1. Suppose the sequence converges to some limit `L`\n"
"2. Set `ε = 1 / 2` and apply the convergence definition\n"
"3. This guarantees some `N` such that `|a n - L| < 1 / 2` for all `n ≥ N`\n"
"4. Consider two specific indices: `n = 2N` and `n = 2N+1` (both are `≥ N`)\n"
"   - `a (2N) = (-1)²ᴺ = 1`, so `|1 - L| < 1 / 2`\n"
"   - `a (2N+1) = (-1)²ᴺ⁺¹ = -1`, so `|-1 - L| < 1 / 2`.\n"
"5. But then:\n"
"\n"
"   `2 = |1 - (-1)| = |(1 - L) + (L + 1)|`\n"
"\n"
"     `≤ |1 - L| + |L + 1|`     [triangle inequality]\n"
"\n"
"     `= |1 - L| + |-1 - L|`    [algebraic manipulation]\n"
"\n"
"     `< 1/2 + 1/2 = 1`         [from steps above]\n"
"6. This gives us `2 < 1`, which is impossible. QED\n"
"\n"
"## Key Insights\n"
"\n"
"- **Geometric intuition:** Any proposed limit L must be within 1/2 of both 1 and -1 simultaneously, but these values are distance 2 apart\n"
"- **Critical ε choice:** We chose ε = 1/2 strategically; larger values like ε = 1.5 wouldn't work since L = 0 could satisfy the constraints.\n"
"- **Triangle inequality:** The key step uses |a + b| ≤ |a| + |b| to convert the distance between sequence values into a sum of distances from the limit.\n"
"\n"
"This proof exemplifies how rigorous definitions resolve historical mathematical debates and provide clear criteria for convergence."
msgstr ""

#: Game.Levels.L6PsetIntro
msgid "Pset 6"
msgstr ""

#: Game.Levels.L6Levels.L03_DotNotation
msgid "Dot Notation"
msgstr ""

#: Game.Levels.L1Pset.L1Pset3
msgid "# Problem 3\n"
"\n"
"You've just learned to add any necessary\n"
"auxiliary\n"
"facts to the list of hypotheses via the\n"
"`have` tactic.\n"
"In this problem,\n"
"you might find the following new idea useful.\n"
"\n"
"You already know that if you\n"
"have a hypothesis `h : X = Y`, and the Goal\n"
"contains `X`, then if you `rewrite [h]`,\n"
"then any instances of `X` in the goal\n"
"get replaced by `Y`.\n"
"But what if you have another hypothesis `h2`,\n"
"and you want to replace `X`'s in `h2` by `Y`s, what should you do then?\n"
"Elementary, my dear Watson!\n"
"You simply type:\n"
"\n"
"`rewrite [h] at h2`.\n"
"\n"
"So the syntax is `rewrite [h]` as before, then\n"
"the word `at`, and finally the name of the\n"
"hypothesis where you want the rewriting to happen.\n"
"Similarly, you can say `ring_nf at h2`,\n"
"and any algebra in hypothesis `h2` will be put into normal form.\n"
"\n"
"Now you should be able to solve this problem!"
msgstr ""

#: Game.Levels.L1PsetIntro
msgid "Pset 1"
msgstr ""

#: Game.Levels.L8Pset.L8Pset4
msgid "If a sequence `σ : ℕ → ℕ` is strictly increasing, then it grows at least linearly."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Multiply the inequality `N ≤ n` by ε: `have f4 : N * ε ≤ n * ε := by bound`"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "The `change` tactic changes a goal to something definitionally equal to it. If the definition of `X` is `Y`, that is, `X := Y`, and the Goal is `X`, you can write `change Y` and the Goal will change to `Y`. You can also\n"
"do this at a hypothesis; if you have a hypothesis `h : X`, you can write `change Y at h`, and `h` will change to `h : Y`."
msgstr ""

#: Game.Levels.L6Pset.L6Pset1
msgid "# Problem 1\n"
"\n"
"You know that `hx : x = 2`, `hy : y = 3`, and that `hz : z = 4`.\n"
"Your goal is to show that: `x = 2 ∧ y = 3 ∧ z = 4`."
msgstr ""

#: Game.Levels.L14Levels.L01_BolzanoWeierstrass
msgid "# Level 1 **Big Boss:**  Bolzano-Weierstass\n"
"\n"
"## New theorems:\n"
"\n"
"- `abs_le` -- just like `abs_lt` but for `|x| ≤ y` instead of `|x| < y`\n"
"\n"
"- `IsCauchyOfAntitoneBdd` (from Pset 12)\n"
"\n"
"- `AntitoneSubseq_of_UnBddPeaks` (to be proved in Pset 13)"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L09_big_boss
msgid "# The Final Challenge\n"
"\n"
"Congratulations! You've learned many fundamental tactics for mathematical reasoning in Lean:\n"
"- `apply hypothesisName` for when a hypothesis matches the goal\n"
"- `rfl` for reflexivity (proving `X = X`)\n"
"- `rewrite [hypothesisName]` for rewriting using equalities\n"
"- `ring_nf` for algebraic manipulation\n"
"- `use` for providing witnesses to existence statements in goals\n"
"- `intro` for handling universal quantifiers in goals\n"
"- `specialize` for applying universal statements to specific values in hypotheses\n"
"- `choose value hypothesisOnValue using ExistentialHypothesis` for extracting information from existence statements in hypotheses\n"
"\n"
"Here's a little \"Universal/Existential Quantifier Cheat Sheet\":\n"
"\n"
"|           | ∀        | ∃      |\n"
"|-----------|----------|--------|\n"
"| **Goal**  | `intro`    | `use`    |\n"
"| **Hypothesis** | `specialize` | `choose` |\n"
"\n"
"Now it's time for your first **Big Boss** - a problem that requires you to use almost ALL of these tactics in a single proof!\n"
"\n"
"**Lecture 1 Big Boss**\n"
"Given a function `f` and information about its behavior, prove a complex statement that involves existence, universals, algebra, and rewriting.\n"
"\n"
"This is what real mathematical proofs look like - a careful orchestration of multiple reasoning steps. You've got this! Use everything you've learned.\n"
"\n"
"**Extra Challenge**\n"
"If you want to *really* challenge yourself, play this level \"blind\". Write the assumptions and goal down on paper, close the computer, solve it by hand, keeping track *in your mind* of what happens to the game board after each command, and only once you’ve worked it all out, open the computer and see if Lean accepts your solution.\n"
"\n"
"Why do you think that this would this be a good thing to do?\n"
"\n"
"In general, I hope your *goal* in taking this course is to make your \"Real Analysis Brain Muscles\" stronger. By the end, you should be *really good* at\n"
"solving Real Analysis problems on paper, where you don't have Lean showing\n"
"you the Goal State after every move.\n"
"More broadly, the purpose of learning to solve Real Analysis problems is to learn to *think*, clearly, precisely. Strengthening your ability to work with pen and paper (or just mentally) directly transfers to *any* other context where you're exploring ideas, wrestling with complicated arguments, or trying to communicate clearly to others.\n"
"\n"
"An LLM could easily work through all these Lean levels by pattern matching and logical manipulation - just as you could solve multiplication problems by plugging them into a calculator instead of memorizing your times tables. But that completely defeats the purpose of the exercise, which is to rewire your brain and build mathematical intuition. It's like deciding that you want to bench press 200 pounds, loading up the bar, and then using a forklift to lift it for you while you stand underneath - you might have moved the weight, but you haven't gotten any stronger. The real value isn't in producing correct proofs, it's in the cognitive transformation that happens when you *struggle* through the reasoning yourself, building the mental pathways that let you see mathematical structure intuitively."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L08_choose
msgid "If you're struggling to prove that `2 ^ 2 = 4`, it's\n"
"a basic fact in a *ring*..."
msgstr ""

#: Game.Levels.L10Lecture
msgid "# Lecture 10: Algebraic Limit Theorem, Part V\n"
"\n"
"Welcome to Lecture 10! We're completing the foundation of sequence theory by tackling three major topics:\n"
"\n"
"## 1. Products of Sequences (The Big Boss!)\n"
"\n"
"We finish the **Algebraic Limit Theorem** by proving that products of convergent sequences converge:\n"
"- If `a n → L` and `b n → M`, then `a n * b n → L * M`\n"
"\n"
"This is the hardest part of the Algebraic Limit Theorem, requiring a clever trick. The geometric intuition comes from thinking about rectangles and the product rule from calculus.\n"
"\n"
"Combined with our earlier work, you'll be able to compute limits of any algebraic expression!\n"
"\n"
"## 2. Order Limit Theorem\n"
"\n"
"Next, we shift from algebra to **inequalities**. Does boundedness pass through limits?\n"
"- If `a n ≤ K` for all `n` and `a n → L`, then `L ≤ K`\n"
"\n"
"This theorem respects the order structure of the real numbers and is fundamental for comparison arguments. We'll prove it by contradiction—a beautiful example of when that technique is the natural choice.\n"
"\n"
"**Warning:** Strict inequalities don't pass through! Even if `a n < K` for all `n`, we only get `L ≤ K`.\n"
"\n"
"## 3. Subsequences\n"
"\n"
"Finally, we introduce **subsequences**—sequences formed by dropping out some terms and sliding everyone to the left.\n"
"\n"
"The key result: **every subsequence of a convergent sequence converges to the same limit**.\n"
"\n"
"The contrapositive gives us a powerful divergence test: if two subsequences converge to different limits, the original sequence diverges!\n"
"\n"
"We'll see this in action with `a n = (-1)^n`, which oscillates but has subsequences converging to 1 (even indices) and -1 (odd indices).\n"
"\n"
"---\n"
"\n"
"**What You'll Learn:**\n"
"\n"
"By the end of this lecture, you'll have:\n"
"- ✅ The complete **Algebraic Limit Theorem** (sums, products, quotients, scalar multiples)\n"
"- ✅ Tools for working with **inequalities and limits**\n"
"- ✅ The **Subsequence Theorem** and how to use it to prove divergence\n"
"- ✅ New proof techniques: geometric thinking for products, contradiction for orders\n"
"\n"
"Let's dive in!"
msgstr ""

#: Game.Levels.L9Levels.L04_FiniteSums
msgid "If a function is nonnegative, then its sum is also."
msgstr ""

#: Game.Levels.L5Levels.L01_DoubleSeqConv
msgid "Now we'll need to show that `0 < ε / 2`. Try: `have eps_half_pos : 0 < ε / 2 := by linarith [hε]`"
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "Archimedean Property"
msgstr ""

#: Game.Levels.L9Pset.L9Pset2
msgid "`N * (N + 1)` is always even."
msgstr ""

#: Game.Levels.L9Pset.L9Pset1
msgid "If `a : ℕ → ℝ` is a sequence which converges, then it is bounded."
msgstr ""

#: Game.Levels.L9Levels.L05_BddOfConv
msgid "# 🎉 Outstanding Achievement!\n"
"\n"
"You've just proven one of the **cornerstone theorems of real analysis**: convergent sequences with nonzero limits are bounded! This is a result you'll use again and again throughout your journey in analysis.\n"
"\n"
"## What You Accomplished\n"
"\n"
"You proved that convergence implies boundedness:\n"
"```\n"
"SeqLim a L → L ≠ 0 → SeqBdd a\n"
"```\n"
"\n"
"This tells us something profound: **convergent sequences can't escape to infinity**. They must remain trapped in a finite region of the real line.\n"
"\n"
"### Key Techniques You Mastered:\n"
"\n"
"1. **Two-region strategy** - You split the natural numbers into two parts:\n"
"   - Eventually (n ≥ N): where convergence gives you control\n"
"   - Initially (n < N): where you used your TermLtSum theorem\n"
"\n"
"2. **Constructing clever bounds** - You built `M = 2*|L| + ∑ k ∈ range N, |a k|`, which elegantly captures both regions in a single expression\n"
"\n"
"3. **Case analysis** - You used `by_cases` to handle the two regions separately, applying the appropriate bound for each\n"
"\n"
"4. **Connecting theorems** - You saw how `TermLtSum` from Level 1 became an essential tool for handling finitely many terms\n"
"\n"
"## Why This Matters\n"
"\n"
"The boundedness of convergent sequences is fundamental throughout mathematics:\n"
"\n"
"- **Bolzano-Weierstrass Theorem**: Every bounded sequence has a convergent subsequence (you've proven half of this!)\n"
"- **Uniform Convergence**: Bounded sequences are essential for proving uniform convergence results\n"
"- **Compactness**: This result is key to understanding compactness in metric spaces\n"
"- **Practical Analysis**: Knowing a sequence stays bounded helps with error analysis and numerical computations\n"
"\n"
"## The Missing Piece: L = 0\n"
"\n"
"Notice we assumed `L ≠ 0` in this proof. The case where `L = 0` is left as an exercise, but the idea is similar:\n"
"- Use convergence with `ε = 1` to bound terms eventually by `1`\n"
"- Handle the finitely many initial terms with TermLtSum\n"
"- The bound becomes `M = 1 + ∑ k ∈ range N, |a k|`\n"
"\n"
"## Looking Ahead\n"
"\n"
"You now understand that convergent sequences live in a bounded world. This prepares you for deeper results:\n"
"- Sequences that are bounded but don't converge (like `(-1)^n`)\n"
"- The relationship between boundedness, monotonicity, and convergence\n"
"- Cauchy sequences and completeness of the reals\n"
"\n"
"Congratulations on mastering this essential theorem! You're building the foundation for advanced analysis. Keep going! 🚀"
msgstr ""

#: Game.Levels.L7Levels.L00_Uniqueness
msgid "If `x ≠ 0`, then `0 < |x|`."
msgstr ""

#: Game.Levels.L12Levels.L00_SubseqIterate
msgid "# Level 1: Iterated Subsequence\n"
"\n"
"Let's warm up to the topics of this lecture with a foundational exercise.\n"
"\n"
"Suppose you have a sequence of natural numbers, `σ : ℕ → ℕ`, and all you know about it is that it always exceeds the identity:\n"
"\n"
"`hσ : ∀ n, n < σ n`\n"
"\n"
"This doesn't mean that `σ n` is itself strictly increasing (what we call a `Subseq`). The sequence could jump around all over the place, as long as its graph stays above that of $y = x$.\n"
"\n"
"But hopefully it's \"intuitively clear\" from `hσ` that `σ` eventually blows up, gets larger and larger over time, just not monotonically so. That is, there should be *some* way to \"accelerate\" `σ` so that it becomes a `Subseq`. The only problem is: how do you *actually* do this?\n"
"\n"
"## The Key Idea: Orbits\n"
"\n"
"The key idea is that of an **orbit**. In astronomy, you can imagine looking up at the sky night after night and trying to track the location of, say, Jupiter against the \"fixed\" stars (celestial sphere). You start your observations with Jupiter having some \"phase-space\" (position, velocity) $x_0$; let $T$ be the function that runs Newtonian dynamics for one day, so that $T(x_0)$ is the new phase-space of Jupiter tomorrow, moving as it does according to Newton's laws and gravity. Then $T(T(x_0))$ is the phase space after two days, and so on. The whole **orbit** of Jupiter over time is then the sequence:\n"
"$$x_0, T(x_0), T(T(x_0)), T(T(T(x_0))), \\ldots$$\n"
"\n"
"More generally, if you have any function $f : X \\to X$ that takes an abstract space $X$ to itself, and you start with some base point $x_0 : X$, then we write $f^{[n]}(x_0)$ for $f$ iterated $n$ times applied to $x_0$. The sequence $n \\mapsto f^{[n]}(x_0)$ is called the \"orbit of $x_0$ under the action of $f$\".\n"
"\n"
"## Application to Our Problem\n"
"\n"
"How does that help us here? We could start with any base point `n₀ : ℕ`, and we know from `hσ` specialized to `n = n₀` that `n₀ < σ n₀`, but we have no idea how big `σ n₀` is; it could be huge. So how do we ensure that the next term exceeds `σ n₀`?\n"
"\n"
"(Want to think about it for a minute before reading on?)\n"
"\n"
"Given our previous discussion, hopefully you see right away that: if we were to specialize `hσ` to `n = σ n₀`, we would get: `σ n₀ < σ (σ n₀)`. So now it's clear: the way to get larger and larger terms from the sequence `σ` is to take the orbit!\n"
"\n"
"**Your goal in this level:** Prove that for any fixed `n₀`, the orbit `n ↦ σ^[n] n₀` is a `Subseq`.\n"
"\n"
"## New Tools\n"
"\n"
"### Function Iteration: `succ_iterate`\n"
"\n"
"While `σ^[k] (σ n) = σ^[k+1] (n)` is true by definition, it takes an argument by induction to show that if instead of adding a `σ` on the right, we add it on the left:\n"
"\n"
"`σ (σ^[k] n) = σ^[k+1] n`\n"
"\n"
"We'll spare you that proof and give you the theorem `succ_iterate`.\n"
"\n"
"### Subsequence from Successor: `subseq_of_succ`\n"
"\n"
"To prove that `σ` is a `Subseq`, the definition speaks of all `i < j`, but it's enough to do it one step at a time. The theorem `subseq_of_succ` says that it's enough to show that `σ n < σ (n+1)` holds for all `n` to conclude `Subseq σ`. You can `apply` this fact to reduce showing `Subseq σ` to just showing that `σ` increases from `n` to `n+1`.\n"
"\n"
"### Tactic: `show`\n"
"\n"
"Syntax: `show fact by proof`. For example, if you want to rewrite by the fact that `σ (σ^[n] n₀) = σ^[n+1] n₀` without a separate `have` declaration, you can write:\n"
"\n"
"`rewrite [show σ (σ^[n] n₀) = σ^[n+1] n₀ by apply succ_iterate]`"
msgstr ""

#: Game.Levels.L13Levels.L03_MonotoneSubseq
msgid "`(a : ℕ → X) := ∀ k, ∃ n > k, IsAPeak a n`\n"
"\n"
"We say that a sequence `a : ℕ → X` (where `X` is `ℚ` or `ℝ`)\n"
"satisfies `UnBddPeaks a`, if its set of peaks is unbounded."
msgstr ""

#: Game.Levels.L10Levels.L09_Subseq
msgid "Excellent! You've shown that the oscillating sequence `(-1)^n` has a convergent subsequence.\n"
"\n"
"**What We Constructed:**\n"
"\n"
"The subsequence `σ(n) = 2*n` extracts the even-indexed terms:\n"
"- Original sequence: `-1, 1, -1, 1, -1, 1, ...`\n"
"- Even subsequence: `1, 1, 1, 1, ...` → converges to 1\n"
"\n"
"**The Other Subsequence:**\n"
"\n"
"Similarly, the odd-indexed subsequence `τ(n) = 2*n + 1` gives:\n"
"- Odd subsequence: `-1, -1, -1, -1, ...` → converges to -1\n"
"\n"
"**Why This Proves Divergence:**\n"
"\n"
"We now have **two subsequences converging to different limits** (1 and -1). By the Subsequence Theorem, if the full sequence `(-1)^n` converged to some limit `L`, then *every* subsequence would have to converge to that same `L`.\n"
"\n"
"But we have subsequences converging to 1 and -1, which are different! This is a contradiction, so `(-1)^n` does not converge.\n"
"\n"
"This is a powerful technique: **to prove divergence, exhibit two subsequences with different limits.**\n"
"\n"
"**The `let` Tactic in Action:**\n"
"\n"
"Notice how `let` allowed us to define `σ` cleanly within the proof. The `fun n ↦ 2*n` syntax creates an anonymous function, and `let` gives it a name we can use.\n"
"\n"
"This is much cleaner than trying to construct the function implicitly!\n"
"\n"
"**Subsequences Extract Hidden Structure:**\n"
"\n"
"Even though `(-1)^n` oscillates wildly and has no limit, by looking at subsequences we can isolate the \"constant behavior\" hidden within:\n"
"- The even terms are constantly 1\n"
"- The odd terms are constantly -1\n"
"\n"
"Subsequences let us zoom in on specific patterns and behaviors that might be obscured in the full sequence.\n"
"\n"
"**Coming Up:**\n"
"\n"
"- Other oscillating sequences with convergent subsequences\n"
"- The **Bolzano-Weierstrass Theorem**: every *bounded* sequence has a convergent subsequence (this is much deeper!)\n"
"- Using subsequences to understand **limsup** and **liminf**\n"
"\n"
"Great work on completing Lecture 10! You now have the complete Algebraic Limit Theorem, order properties of limits, and the power of subsequences at your disposal."
msgstr ""

#: Game.Levels.L13Lecture
msgid "Lecture 13: Monotone Subsequence"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Again, you presumably you know\n"
"now to do `intro n hn`. But let's also give `hn` the more descriptive name `n_ge_N`. So that I can keep giving you hints, try `intro n n_ge_N`."
msgstr ""

#: Game.Levels.L10Pset.L10Pset4
msgid "# Problem 3:\n"
"\n"
"We proved `OrderLimLe`; now prove `OrderLimGt`. Notice that the assumption is a **strict** inequality, but the conclusion is not. Why not? (See next Exercise...)"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L00_the_problem
msgid "# Theorem Prover Software\n"
"\n"
"In this course, we will be using a \"proof assistant\" called Lean. This is software that checks that our proofs prove *exactly* what we\n"
"claim they prove. It has other really cool pedagogical features that we'll get to later.\n"
"It will take a little while to get used to the syntax, so until we're comfortable, we'll intersperse exercises teaching Lean with exercises teaching Real Analysis. Pretty soon all the exercises will just be about Real Analysis.\n"
"\n"
"\n"
"For this first exercise, we have a hypothesis that we called `h` (but we could've called it anything, like `x_eq_5`, or `Alice`) that says a real number `x` equals 5. Our goal is to prove that `x` equals 5.\n"
"This shouldn't be very hard, but if you don't know\n"
"the command, you'll be out of luck. Our goal is to\n"
"prove the same statement as one of the hypotheses.\n"
"To solve that goal, the syntax is to write `apply`, then a space, and then the name of the hypothesis which matches the goal."
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Prove that the sequence `a(n) = 1 / n` converges to 0.\n"
"This is our first substantive limit proof, requiring the Archimedean Property."
msgstr ""

#: Game.Levels.L7PsetIntro
msgid "Pset 7"
msgstr ""

#: Game.Levels.L10Levels.L06_Prod
msgid "Congratulations! You've completed the hardest part of the Algebraic Limit Theorem.\n"
"\n"
"Postscript:\n"
"**Why would you think to add and subtract `b n * L`?**\n"
"\n"
"Think about the product rule in calculus: `(fg)' = f'g + fg'`. Multiplication always corresponds to a rectangle. When you have two quantities `f` and `g` both changing, the change in their product `fg` can be visualized as the change in area:\n"
"\n"
"```\n"
"      f        Δf\n"
"   +-----+-------+\n"
"   |     |       |\n"
" g |     |       |\n"
"   +-----+-------+\n"
" Δg|     |  tiny |\n"
"   +-----+-------+\n"
"```\n"
"\n"
"The total change is `(f + Δf)(g + Δg) - fg = f·Δg + g·Δf + Δf·Δg`.\n"
"\n"
"In our proof, we replaced `M` with `b n` (adding and subtracting `b n * L`) to get the same decomposition. The `Δf·Δg` term (the tiny corner) gets absorbed into `(a n - L) * b n`, and since both factors are small, it doesn't cause problems.\n"
"\n"
"This geometric picture explains the algebraic trick: we're decomposing the area difference into two manageable strips that we can control independently.\n"
"\n"
"# Algebraic Limit Theorem - Complete!\n"
"\n"
"You can now:\n"
"- **Add** sequences: if `a n → L` and `b n → M`, then `a n + b n → L + M`\n"
"- **Multiply by constants**: if `a n → L`, then `c * a n → c * L`\n"
"- **Multiply** sequences: if `a n → L` and `b n → M`, then `a n * b n → L * M`\n"
"- **Invert** (when limit is nonzero): if `a n → L ≠ 0`, then `1 / a n → 1 / L`\n"
"\n"
"This is incredibly powerful! For any algebraic combination of convergent sequences, you can compute the limit by just plugging in the individual limits.\n"
"\n"
"**Example:** If `a n → L` and `b n → M`, what is\n"
"```\n"
"lim ((a n)² + 2*a n + b n) / (3*b n + 2 - (a n)²)\n"
"```\n"
"\n"
"**Answer:** `(L² + 2*L + M) / (3*M + 2 - L²)` (provided the denominator ≠ 0).\n"
"\n"
"You can build this up step by step using the algebraic limit rules!\n"
"\n"
"**Note:** The case where `L = 0` or `M = 0` is left as an exercise. The proof requires slightly different techniques since you can't divide by `|L|` or ensure `b` is bounded away from zero. Try it yourself!"
msgstr ""

#: Game.Levels.L1Pset.L1Pset3
#: Game.Levels.L1Pset.L1Pset4
#: Game.Levels.L1Pset.L1Pset5
msgid "Solve the problem"
msgstr ""

#: Game.Levels.L1PsetIntro
msgid "# Problem Set 1\n"
"\n"
"Just because it's a problem set doesn't mean\n"
"you can't learn new things..."
msgstr ""

#: Game.Levels.L8Levels.L03_Induction'
msgid "If a natural number `n ≠ 0`, then `1 ≤ n`."
msgstr ""

#: Game.Levels.L6Levels.L05_AbsLt
msgid "# 📐 Absolute Value Mastery Achieved! 📐\n"
"\n"
"Outstanding! You've just completed a proof that demonstrates the power of combining logical reasoning with analytical techniques. This type of argument—extracting bounds from convergence conditions—is absolutely fundamental in real analysis.\n"
"\n"
"**Why This Matters:**\n"
"What you just proved is that any convergent sequence is eventually bounded below (relative to its limit). This might seem like a small technical detail, but it's actually a building block for many major theorems. For instance, this type of reasoning is crucial in proving that convergent sequences are bounded, and that continuous functions on compact sets achieve their minima.\n"
"\n"
"**The Strategic Breakdown:**\n"
"Notice the elegant flow of your proof: you started with the abstract convergence condition, chose a specific `ε` (namely `1`), extracted the absolute value condition, unpacked it using `abs_lt` to get both bounds, and then focused on just the bound you needed. This is mathematical reasoning at its finest—systematic, precise, and efficient.\n"
"\n"
"**Technical Insight:**\n"
"The `abs_lt` theorem is your gateway between the world of absolute values (which are natural for expressing \"closeness\") and the world of ordinary inequalities (which are easier to manipulate algebraically). Learning to move fluently between these representations is a key skill in analysis.\n"
"\n"
"**Looking Forward:**\n"
"As we progress to more advanced topics, you'll find yourself using this pattern repeatedly: taking convergence hypotheses, specializing them to specific epsilons, and then extracting the directional information you need. The techniques you've mastered here will be essential for proving results about monotonic sequences, bounded sequences, and much more.\n"
"\n"
"You're not just learning tactics—you're developing the analytical intuition that separates novice proof-writers from experienced mathematicians. Keep building on these foundations!"
msgstr ""

#: Game.Levels.L10Pset.L10Pset4
msgid "If a sequence `a` converges to `L` and `K < a n` for all `n`, then `K ≤ L`."
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "Prove that the sequence `1`, `-1`, `1`, `-1`,... diverges."
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "While you may see `0 < ε` in the goal and `ε > 0` in the hypothesis `hε`, Lean will still know that these two things are exactly the same..."
msgstr ""

#: Game.Levels.L10Levels.L09_Subseq
msgid "The `let` tactic is like `have`, but for creating variable names or functions."
msgstr ""

#: Game.Levels.L10Levels.L07_Order
msgid "If a sequence `a` converges to `L` and `a n ≤ K` for all `n`, then `L ≤ K`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "# Universal statements\n"
"\n"
"In mathematics, we often need to prove statements that are true \"for all\" values of some variable. For example, we might want to prove: \"for all $\\varepsilon > 0$, we have $(\\varepsilon + 1)^2 = (\\varepsilon + 1)^2$.\"\n"
"(Of course the condition that `ε` be positive is mathematically superfluous, and is only here for pedagogical purposes.)\n"
"\n"
"If you're thinking that `rfl` will do the trick, that's a good idea, but it won't work, because the goal isn't (yet) an equality. So we need to do something else first.\n"
"\n"
"In Lean, as in mathematics, \"for all\" is written using `∀`; this is called the *universal quantifier*, and is gotten by typing \\forall, that is, backslash, then `forall`, then a space. In Lean, this goal looks like so:\n"
"\n"
"`∀ ε > 0, (ε + 1)^2 = (ε + 1)^2`.\n"
"\n"
"(Note that to write an epsilon in Lean, you just type \\\\e, that is, backslash, then `e`, then space.)\n"
"\n"
"To prove a \"for all\" statement, you need to show that it's true for an arbitrary element. In English, you would say: give me an arbitrary `ε`, and give me the fact that it's positive (we can give that fact a name, like `hε`, since it's a hypothesis about `ε`, or perhaps an even more descriptive name like `ε_pos`, since the hypothesis is the positivity of `ε`). Note that `ε` here is a dummy variable, and we could choose to name it something else on the fly. In English, we might say: give me some `ε`, but I want to call it `Alice`; then give me the fact that `Alice` is positive, and my goal will be to prove that `(Alice + 1)^2 = (Alice + 1)^2`. If we were more polite, we might replace \"give me\" above with \"introduce\", like:\n"
"introduce an `ε`, and introduce the fact, call it `hε`, that `ε` is positive.\n"
"\n"
"In Lean, the syntax for this is the command `intro`, followed by whatever name you want to give a dummy variable or a hypothesis.\n"
"\n"
"So: when you see a goal that starts with `∀`, you can write `intro` to \"introduce\" the variable. For example:\n"
"- `intro ε` introduces the variable ε. But look at the goal state now! It changes to: `ε > 0 → (ε + 1)^2 = (ε + 1)^2`. So we're not done introducing things.\n"
"- Then `intro hε` introduces the hypothesis that `ε > 0` (and again, you can call the hypothesis whatever you want; try `intro ε_pos` instead).\n"
"\n"
"After using `intro` twice, the goal will become one that you\n"
"should know how to solve.\n"
"\n"
"If you want to be really slick, you can combine the two `intro` commands into\n"
"one: `intro ε hε`. But don't feel obliged."
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "# Level 1: The Archimedean Property\n"
"\n"
"The so-called Archimedean Property (which I think is originally due to Eudoxus, and appears already in Euclid's Elements Book V) is a fundamental property of the real numbers that captures the intuitive notion that there are no \"infinitely large\" or \"infinitesimally small\" positive real numbers.\n"
"\n"
"More precisely, it states that no matter how small `ε > 0` is, there is always a natural number `N` so that `1 / N` is even smaller than `ε` (and of course positive). Equivalently, we can state it as: for any positive real number `ε`, there exists a natural number `N` such that `1 / ε < N`.\n"
"\n"
"*Why does this matter?* The Archimedean Property is one of the most fundamental properties distinguishing the real numbers from other number systems. Without it, we could have \"infinitely large\" or \"infinitesimally small\" positive numbers, which would break most of calculus and analysis.\n"
"\n"
"Our goal will be to prove the following:\n"
"\n"
"**Theorem (ArchProp)**: For any `ε : ℝ` with `0 < ε`, there exists `N : ℕ` such that `1 / ε < N`.\n"
"\n"
"This is mathematically \"obvious\" to most people—if you have a positive number ε, no matter how small, you can always find a natural number large enough that 1 / ε is smaller than it. (At least it seems obvious, and perhaps becomes less so once you remember that we don't yet know what the real numbers actually *are*... We'll continue postponing the construction for some time.) But how do you actually formalize this in Lean?\n"
"\n"
"## The Natural Language Proof Strategy\n"
"\n"
"First, let's think about this in natural language. The key insight is that we need to provide a specific natural number `N` that works.\n"
"\n"
"A natural choice would be to use something related to the ceiling function. The ceiling function `x ↦ ⌈x⌉` rounds any real number up to the nearest integer. However, there's a subtle issue here: the standard ceiling function takes values in integers `ℤ`, but we need values in `ℕ` (the natural numbers). These are *not* the same thing!!\n"
"\n"
"Fortunately, Lean provides the \"natural number ceiling function\" written `x ↦ ⌈x⌉₊`, which takes any real number and returns a natural number.\n"
"(You can write these symbols using `\\lceil`, `\\rceil`, and `\\_+`. Or if you're lazy like me, just copy and paste them from elsewhere.)\n"
" For negative inputs, this function returns `0`. For example, `⌈-3.14⌉₊ = 0` and `⌈3.14⌉₊ = 4`.\n"
"\n"
"Now our strategy becomes clear:\n"
"- **Choice of N**: Use `N = ⌈1 / ε⌉₊ + 1`\n"
"- **Why this works**: We have the \"key inequality\": `1 / ε ≤ ⌈1 / ε⌉₊`, which holds by the definition of the ceiling function\n"
"- **Getting strict inequality**: Adding 1 gives us `1 / ε < ⌈1 / ε⌉₊ + 1`\n"
"\n"
"## The Lean Implementation Challenges\n"
"\n"
"In Lean, the first two steps of our natural language proof work fine, but then we encounter the issue of **type coercion** (\"casting\" between different number types). We'll discuss this in more detail later, but again it has to do with the fact that `ℕ`, `ℤ`, `ℚ`, and `ℝ` are all different kinds of things, and we need to be able to move numbers up the \"sophistication\" heirarchy, with natural numbers being the simplest objects and the reals being the most complicated (so much so that we keep postponing their construction).\n"
"\n"
"For example, notice that when we'll write our `have` statement to establish the key inequality:\n"
"\n"
"`have fact : 1 / ε ≤ ⌈1 / ε⌉₊ := by WhateverTheProofIs`\n"
"\n"
"Lean will record it as:\n"
"\n"
"`fact : 1 / ε ≤ ↑⌈1 / ε⌉₊`\n"
"\n"
"Notice the mysterious up arrow `↑`. This represents a coercion function from natural numbers to real numbers:\n"
"\n"
"↑ : ℕ → ℝ\n"
"\n"
"This is because `ℕ`, `ℤ`, `ℚ`, and `ℝ` are all **different** types in Lean's type system (and really, in mathematics, as we'll see when we construct the real numbers)! Even though we think of natural numbers as being \"contained\" in the real numbers, formally they are distinct types of things, and Lean needs explicit coercion functions to convert between them.\n"
"\n"
"*Think of it this way*: the natural number `3 : ℕ` and the fraction `3 / 1 : ℚ` and the real number `3.000 : ℝ` are different objects that just happen to represent the same mathematical value.\n"
"\n"
"The `push_cast` tactic helps manage these coercions, kind of like `ring_nf` but for casting instead of ring operations.\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"- `⌈ ⬝ ⌉₊`: The natural number ceiling function\n"
"- `push_cast`: Tactic that handles coercions between number types\n"
"- `bound`: Solves many routine inequalities\n"
"\n"
"The `bound` tactic can solve many \"trivial\" inequalities once the types are properly aligned.\n"
"\n"
"## Hint:\n"
"\n"
"If you get stuck and don't see a Hint, try backtracking until you do."
msgstr ""

#: Game.Levels.L4Pset.L4Pset1
msgid "Prove that this sequence diverges."
msgstr ""

#: Game.Levels.L3Lecture
msgid "# More on sequences\n"
"\n"
"In Lecture 2, we learned the definition of a sequence `a : ℕ → ℝ` converging to a limit `L`: for any tolerance\n"
"`ε > 0`, there exists a time `N`, so that, for any point after that time, `n ≥ N`, we are within the tolerance, `|a n - L| < ε`.\n"
"\n"
"We also learned how to do something completely trivial with it, namely, show that the constant sequence converges, with that constant as its limit.\n"
"\n"
"Let's step it up a notch, shall we?"
msgstr ""

#: Game.Levels.L12Levels.L02_IterateGap
msgid "Prove `IterateGap`"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! 🎉"
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "NonConvergence"
msgstr ""

#: Game.Levels.L7Levels.L04_ByCases
msgid "## Case Analysis Mastered!\n"
"\n"
"You've now learned how to perform case analysis even when you don't have an existing hypothesis\n"
"to split on. The `by_cases` tactic is a powerful addition to your proof toolkit.\n"
"\n"
"## What You Accomplished\n"
"\n"
"In this level, you proved `EventuallyGeHalfLim` without assuming `L ≠ 0`, making it strictly\n"
"more general than `EventuallyGeHalfLimPos`. The proof was elegant:\n"
"- When `L = 0`, the inequality becomes trivial since both sides equal zero\n"
"- When `L ≠ 0`, you could invoke your earlier theorem\n"
"\n"
"This pattern -- handling edge cases separately, then applying more powerful results in the main\n"
"case -- is ubiquitous throughout mathematics.\n"
"\n"
"## The Power of Case Analysis\n"
"\n"
"The `by_cases` tactic allows you to:\n"
"- **Prove more general theorems** by removing unnecessary assumptions and handling special cases\n"
"- **Organize complex proofs** by separating different scenarios that require different strategies\n"
"- **Handle edge cases systematically** rather than hoping they don't arise\n"
"- **Make logical structure explicit** by formally splitting on conditions that matter\n"
"\n"
"## When to Reach for `by_cases`\n"
"\n"
"You'll find `by_cases` particularly useful when:\n"
"- Your proof strategy differs significantly based on whether some condition holds\n"
"- You need to handle a potential edge case (like zero denominators, empty sets, etc.)\n"
"- You want to generalize a theorem by removing a hypothesis and treating it as a case\n"
"- The problem naturally divides into distinct scenarios\n"
"\n"
"## Looking Ahead\n"
"\n"
"Combined with `cases'` for existing hypotheses and `split_ands` for conjunctions, you now\n"
"have a complete toolkit for working with logical connectives in Lean. These techniques will\n"
"serve you throughout your journey in formal mathematics, from basic analysis to abstract\n"
"algebra and beyond.\n"
"\n"
"The ability to systematically handle all cases is what makes mathematical proofs rigorous and\n"
"complete. You're well on your way to mastering the art of formal proof!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "This is where you might find it useful to call `norm_num` and normalize `|0|` to `0`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L06_intro
msgid "For all positive real numbers, this algebraic identity holds."
msgstr ""

#: Game.Levels.L12PsetIntro
msgid "# Problem Set 12\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
#: Game.Levels.L2Pset.L2Pset1
#: Game.Levels.L3Pset.L3Pset1
#: Game.Levels.L4Pset.L4Pset1
#: Game.Levels.L6Pset.L6Pset1
#: Game.Levels.L7Pset.L7Pset1
#: Game.Levels.L8Pset.L8Pset1
#: Game.Levels.L9Pset.L9Pset1
#: Game.Levels.L10Pset.L10Pset2
#: Game.Levels.L11Pset.L11Pset1
#: Game.Levels.L12Pset.L12Pset1
#: Game.Levels.L13Pset.L13Pset1
msgid "Problem 1"
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L05_use
msgid "Write `use 42`, but with `42` replaced by the correct answer. Then how should you finish?"
msgstr ""

#: Game.Levels.L6Levels.L02_LeftRight
msgid "When your goal is to prove an \\\"Or\\\" statement, `P ∨ Q`, you can do that by proving either `P` or `Q`. If you want to prove `P`, then say `left`, and the Goal will turn into `P`."
msgstr ""

#: Game.Levels.L12Levels.L00_SubseqIterate
msgid "The `show` tactic has syntax `show fact by proof`."
msgstr ""

#: Game.Levels.L8PsetIntro
msgid "# Problem Set 8\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L3Pset.L3Pset3
msgid "# Problem 3\n"
"\n"
"Determine what the limit of the sequence `1 / n ^ 2` is, and prove it.\n"
"\n"
"Hints you may find useful:\n"
"- We have yet to learn about dealing with the square-root function.\n"
"So see if you can be even lazier in your choice of parameters...\n"
"- If you know that `h : 0 < N` holds in the *natural* numbers, then you can prove that that `1 ≤ N` simply by `apply`ing `h`, that is: `have h' : 1 ≤ N := by apply h`. (This would not work for an inequality in the real numbers, since it's in general not true!)"
msgstr ""

#: Game.Levels.L6Levels.L06_Squeeze
msgid "# 🏆 Squeeze Theorem Conquered! 🏆\n"
"\n"
"Magnificent! The Squeeze Theorem is not just mathematically beautiful—it's also incredibly practical and will serve you throughout your mathematical journey.\n"
"\n"
"**Why This Is a Big Deal:**\n"
"The Squeeze Theorem is a workhorse of mathematical analysis. It's the tool that lets us prove challenging convergence results by reducing them to easier problems. Can't directly show that a complex sequence converges? Find two simpler sequences that squeeze it, and you're done!\n"
"\n"
"**Technical Mastery:**\n"
"Notice how your proof elegantly combined multiple techniques: epsilon-N arguments, absolute value manipulation with `abs_lt`, logical decomposition with `split_ands`, and inequality reasoning. This synthesis of tools is what makes advanced mathematical proof possible.\n"
"\n"
"**The Power of Transitivity:**\n"
"The heart of your proof was recognizing that if `L - ε < a(n) ≤ b(n) ≤ c(n) < L + ε`, then by transitivity, `L - ε < b(n) < L + ε`, which is exactly what we needed. This kind of inequality chaining is fundamental to analysis.\n"
"\n"
"**Real-World Applications:**\n"
"This theorem proves convergence for sequences that would be nearly impossible to handle directly. For example:\n"
"- `sin(1/n) → 0` (squeezed between `-1/n` and `1/n`)\n"
"- Recursive sequences where exact formulas are intractable\n"
"- Sequences defined by complex geometric or probabilistic processes\n"
"\n"
"**Looking Forward:**\n"
"The Squeeze Theorem will reappear throughout analysis: in proving continuity results, establishing uniform convergence, and even in advanced topics like measure theory. You've now mastered not just the theorem itself, but the proof techniques that make it work.\n"
"\n"
"You're developing the kind of mathematical sophistication that allows you to see structure and opportunity where others see only complexity. That's the mark of a true mathematician!"
msgstr ""

#: Game.Levels.L3Levels.L02_OneOverN
msgid "Simplify the absolute value: `have f2 : |1 / (n : ℝ)| = 1 / n := by bound`. Note the explicit casting to the reals, so that this is not a statement about natural numbers!"
msgstr ""

#: Game.Levels.L2NewtonsCalculationOfPi.L01_SeqConvDef
msgid "# 🎉 Excellent Work! 🎉\n"
"\n"
"You've just completed your first rigorous limit proof! Let's reflect on what you accomplished and the key insights from this foundational example.\n"
"\n"
"**What you just proved:**\n"
"You showed that if a sequence always outputs the same value `L`, then it converges to `L`. The Machinist's response to any tolerance demand `ε > 0` is beautifully simple: 'I can meet that specification immediately with any production run length `N`, because I'm already producing exactly what you want!'\n"
"\n"
"**Key Insights from this proof:**\n"
"\n"
"1. **The `change` tactic**: You learned how to unfold a definition to see what you're really trying to prove. `SeqLim a L` became the concrete epsilon-N condition.\n"
"\n"
"2. **The logical structure**: The proof followed the natural flow of the definition:\n"
"   - `intro ε hε` handled 'for every ε > 0'\n"
"   - `use 1` provided the witness `N` (any number works!)\n"
"   - `intro n hn` handled '∀ n ≥ N'\n"
"   - Then algebraic manipulation showed that `|a n - L| = |L - L| = |0|`\n"
"   - Then numerical normalization gave that `|0| = 0`, and `hε` finally proved that `|a n - L| < ε`.\n"
"\n"
"**The Beautiful Simplicity:**\n"
"This is the Machinist's dream scenario—no matter how demanding the engineer's tolerance requirements, the constant factory can satisfy them instantly. There's no trade-off between precision and effort because the output is already perfect!\n"
"\n"
"You're building the foundation for all of calculus. Every limit, derivative, and integral ultimately rests on arguments like this one.\n"
"\n"
"## Check in, in Natural Language\n"
"\n"
"Let's step back from the formal Lean proof and understand what we just proved in plain English.\n"
"\n"
"**Theorem (in natural language):** If a sequence has the same value for every term, then it converges to that constant value.\n"
"\n"
"**Proof:** Suppose we have a sequence $a(n)$ where $a(n) = L$ for all $n$, and we want to show that this sequence converges to $L$.\n"
"\n"
"By definition, we need to show that for any tolerance $\\varepsilon > 0$, we can find a point $N$ such that for all $n \\geq N$, we have $|a(n) - L| < \\varepsilon$.\n"
"\n"
"This is almost trivially simple: since $a(n) = L$ for every $n$, we have:\n"
"$$|a(n) - L| = |L - L| = |0| = 0$$\n"
"\n"
"Since $0 < \\varepsilon$ for any positive $\\varepsilon$, we can choose any $N$ we want (we chose $N = 1$ in the proof, but $N = 0$ or $N = 1000$ would work equally well).\n"
"\n"
"Therefore, for any $n \\geq N$, we have $|a(n) - L| = 0 < \\varepsilon$, which proves convergence.\n"
"**QED**"
msgstr ""

#: Game.Levels.L1Pset.L1Pset1
msgid "Given that `f (u) = 2 * u + 1` for all `u`, prove that there exists some `a` such that `f (3) = a`."
msgstr ""

#: Game.Levels.L11Levels.L03_IsBddOfCauchy
msgid "# Level 3: Cauchy Implies Bounded\n"
"\n"
"We've seen that convergent sequences are bounded. Now we'll prove that **Cauchy sequences are also bounded**—without ever mentioning a limit!\n"
"\n"
"This is a beautiful result because it shows that the Cauchy property alone (terms getting close to *each other*) is strong enough to guarantee boundedness, even though we don't know if the sequence converges or *where* it might converge to.\n"
"\n"
"## The Setup\n"
"\n"
"Given:\n"
"- `a : ℕ → ℝ` is Cauchy\n"
"\n"
"Prove: `a` is bounded (i.e., `∃ M, ∀ n, |a n| ≤ M`)\n"
"\n"
"## The Key Insight\n"
"\n"
"If a sequence is Cauchy, then eventually all terms are clustered together. Specifically, if we use `ε = 1` in the Cauchy definition, then for all `m ≥ N`, we have:\n"
"\n"
"$|a_m - a_N| < 1$\n"
"\n"
"This means all terms after `N` stay within distance 1 of $a_N$, so they're all bounded by $|a_N| + 1$.\n"
"\n"
"But what about the finitely many terms *before* `N`? We just take their maximum (or what's technically easier: their sum)!\n"
"\n"
"## Strategy\n"
"\n"
"1. **Apply Cauchy with `ε = 1`**: Get an `N` such that all terms after `N` are within distance 1 of $a_N$\n"
"2. **Bound the tail**: Show that for `m ≥ N`, we have $|a_m| ≤ |a_N| + 1$ using the triangle inequality\n"
"3. **Bound the initial segment**: The terms $a_0, a_1, ..., a_{N-1}$ are finitely many, so their sum of absolute values bounds each one\n"
"4. **Combine**: Take $M = |a_N| + 1 + \\sum_{k < N} |a_k|$ as your overall bound\n"
"5. **Case split**: Use `by_cases` to handle `m < N` versus `m ≥ N` separately\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.L6Levels.L04_Cases'
msgid "Cases'"
msgstr ""

#: Game.Levels.L5Lecture
msgid "# More on sequences\n"
"\n"
"\n"
"The so-called Algebraic Limit Theorem for sequences says that: if `a` and `b` are two sequences, `a b : ℕ → ℝ`, and `L` and `M` are two real numbers, with `lim a = L` and `lim b = M`, then:\n"
"\n"
"- (i) for any constant `c`, `lim c * a = c * L`\n"
"- (ii) `lim (a + b) = L + M`\n"
"- (iii) `lim (a * b) = L * M`, and\n"
"- (iv) `lim (a / b) = L / M`, as long as `M ≠ 0`.\n"
"\n"
"Let's get started."
msgstr ""

#: Game.Levels.L8Levels.L03_Induction'
msgid "The syntax for induction is: `induction' n with k hk`. This means: apply induction on the\n"
"variable `n`, use `k` for the new dummy variable (which could be `n` itself), and `hk` for\n"
"the induction hypothesis on `k`."
msgstr ""

#: Game.Levels.L1RealAnalysisStory.L07_specialize
msgid "# Using universal statements\n"
"\n"
"Now let's learn the flip side of `intro`. You have already learned that:\n"
"- if you have `∃` in the goal, you write `use` to provide a specific value. And\n"
"- if you have `∀` in the goal, you write `intro` to introduce an arbitrary variable\n"
"\n"
"But what if you have `∀` in a *hypothesis* and you want to use it for a particular value?\n"
"\n"
"For a concrete example, suppose you have:\n"
"- A positive real number `t`; that is, a real number `t`, together with a hypothesis, say, `t_pos` that `t > 0`\n"
"- A function `f : ℝ → ℝ`\n"
"- A hypothesis `hf : ∀ x > 0, f (x) = x^2`, meaning \"for all x positive, f (x) equals x²\". (Note that you *have* to put a space after `f` before `(x)` or else Lean will be very angry with you! In fact, Lean will often drop unnecessary parentheses, so you'll see `f x` instead of `f (x)` -- and again, definitely *not* `f(x)`.)\n"
"- And you want to prove the goal `f (t) = t^2`.\n"
"\n"
"Can you use `apply hf`? No! The hypothesis `hf` says \"for all positive x, f (x) = x²\" but the goal asks specifically about `f (t) = t²`. They're not  the same.\n"
"\n"
"This is where the `specialize` command comes in. You can write `specialize hf t` to specialize the statement `hf` to the particular value `t`. This transforms `hf` from \"∀ x > 0, f (x) = x²\" into \"t > 0 → f (t) = t²\". Just like we had to `intro` multiple times (once for the dummy variable name, and again to name the hypothesis), we can specialize multiple times; so you can now write `specialize hf t_pos`. Or you can kill two birds with one stone via: `specialize hf t t_pos`.\n"
"\n"
"I'm sure you can solve the goal from there yourself!"
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "Usage: `have factName : |x + y| ≤ |x| + |y| := by apply abs_add`"
msgstr ""

#: Game.Levels.L12Levels.L01_Choose
msgid "Try starting your proof with `choose τ hτBnd hτP using h`."
msgstr ""

#: Game.Levels.L4Levels.L01_NonConverge
msgid "Usage: `have factName : |-x| = |x| := by apply abs_neg`"
msgstr ""

#: Game.Levels.L3Levels.L01_ArchProp
msgid "The `bound` tactic can solve many \\\"trivial\\\" inequalities involving standard functions and basic arithmetic."
msgstr ""

#: Game.Levels.L9Levels.L05_BddOfConv
msgid "# Level 2: Bounded\n"
"\n"
"Welcome to one of the most fundamental results in real analysis: **convergent sequences are bounded**! This theorem tells us that if a sequence converges to a limit, it can't wander off to infinity—it must stay within some finite region.\n"
"\n"
"## The Goal\n"
"\n"
"Prove that if `a : ℕ → ℝ` converges to a nonzero limit `L`, then `a` is bounded (i.e., there exists some `M > 0` such that `|a n| ≤ M` for all `n`).\n"
"\n"
"**Note:** The case `L = 0` will be handled in the exercises. For now, we focus on nonzero limits.\n"
"\n"
"## The Big Idea\n"
"\n"
"Think about what convergence means: eventually, all terms get close to `L`. So for large `n`, we have `|a n| ≤ 2|L|` (approximately).\n"
"\n"
"But what about the **finitely many terms before** the sequence gets close to `L`? That's where your `TermLeSum` theorem from Level 1 comes in! You can bound those initial terms by their finite sum.\n"
"\n"
"### The Strategy:\n"
"\n"
"1. **Eventually bounded:** Use `EventuallyBdd_of_SeqConv` to find an `N` such that `|a n| ≤ 2|L|` for all `n ≥ N`\n"
"\n"
"2. **Initially bounded:** For `n < N`, use `TermLeSum` to show `|a n| ≤ ∑ k ∈ range N, |a k|`\n"
"\n"
"3. **Global bound:** Combine both parts with:\n"
"   ```\n"
"   M = 2 * |L| + ∑ k ∈ range N, |a k|\n"
"   ```\n"
"\n"
"   This works because:\n"
"   - For `n ≥ N`: the term `|a n|` is covered by `2|L|`\n"
"   - For `n < N`: the term `|a n|` is covered by the sum\n"
"\n"
"4. **Prove `M > 0`:** Show that your bound is positive (needed for the definition of `SeqBdd`)\n"
"\n"
"5. **Prove `∀ n, |a n| ≤ M`:** Split into cases based on whether `n ≥ N` or `n < N`\n"
"\n"
"## New Tools You'll Need\n"
"\n"
"### `SeqBdd`\n"
"Definition: A sequence `a : ℕ → ℝ` is **bounded** if `∃ M > 0, ∀ n, |a n| ≤ M`\n"
"\n"
"## Your Mission\n"
"\n"
"Construct the bound `M`, prove it's positive, then verify it works for all terms by splitting into the two cases. Let your `TermLeSum` theorem shine!\n"
"\n"
"Good luck! 🚀"
msgstr ""

#: Game.Levels.L1Pset.L1Pset5
#: Game.Levels.L6Pset.L6Pset5
#: Game.Levels.L10Pset.L10Pset6
msgid "Problem 5"
msgstr ""

#: Game.Levels.L9Levels.L05_BddOfConv
msgid "Bounded"
msgstr ""

#: Game.Levels.L12Pset.L12Pset1
msgid "`(a : X → Y) {i j} (hij : i ≤ j) : a j ≤ a i`\n"
"\n"
"A sequence `a : X → Y` is said to be `Antitone` if `a m ≤ a n` whenever `n ≤ m` (note that `n` and `m` were reversed)."
msgstr ""
